<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Marshwallen • Posts by &#34;flutter&#34; tag</title>
        <link>https://onlie202.github.io</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Thu, 14 Mar 2024 14:28:01 +0800</pubDate>
        <lastBuildDate>Thu, 14 Mar 2024 14:28:01 +0800</lastBuildDate>
        <category>Nginx</category>
        <category>Android</category>
        <category>Flutter</category>
        <category>Ubuntu</category>
        <category>Others</category>
        <item>
            <guid isPermalink="true">https://onlie202.github.io/2024/03/14/Flutter%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/</guid>
            <title>Flutter基础与实战</title>
            <link>https://onlie202.github.io/2024/03/14/Flutter%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/</link>
            <category>Android</category>
            <category>Flutter</category>
            <pubDate>Thu, 14 Mar 2024 14:28:01 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;flutter基础与实战从入门到app跨平台开发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#flutter基础与实战从入门到app跨平台开发&#34;&gt;#&lt;/a&gt; Flutter 基础与实战：从入门到 APP 跨平台开发&lt;/h1&gt;
&lt;h2 id=&#34;第一章基础知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第一章基础知识&#34;&gt;#&lt;/a&gt; 第一章：基础知识&lt;/h2&gt;
&lt;h3 id=&#34;11-dart语言概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#11-dart语言概述&#34;&gt;#&lt;/a&gt; 1.1 Dart 语言概述&lt;/h3&gt;
&lt;p&gt;JIT 全称为 Just in Time（即时编译）&lt;/p&gt;
&lt;p&gt;AOT 全称为 Ahead of Time（事前编译）&lt;/p&gt;
&lt;p&gt;Flutter 在 Debug 模式下使用了 Kernel Snapshot 编译模式&lt;/p&gt;
&lt;p&gt;Dart 的 bytecode 模式，不区分架构，Flutter 项目内也叫作 Core Snapshot，可以归类为 AOT 编译&lt;/p&gt;
&lt;h3 id=&#34;12-dart语言核心&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#12-dart语言核心&#34;&gt;#&lt;/a&gt; 1.2 Dart 语言核心&lt;/h3&gt;
&lt;p&gt;强类型语言&lt;/p&gt;
&lt;p&gt;var、dynamic 用来声明动态类型变量&lt;/p&gt;
&lt;p&gt;var 一旦指定类型后，后期是不能再次修改类型的&lt;/p&gt;
&lt;p&gt;dynamic 关键字声明的数据类型与 JavaScript 中的一致&lt;/p&gt;
&lt;p&gt;number 类型分为 int 和 double&lt;/p&gt;
&lt;p&gt;没有 float 类型&lt;/p&gt;
&lt;p&gt;bool 类型相当于 Java 中的 boolean 与 Objective-C 中的 BOOL&lt;/p&gt;
&lt;p&gt;Dart 中也有箭头函数&lt;/p&gt;
&lt;p&gt;Map 用来存储对象类型的数据&lt;/p&gt;
&lt;p&gt;List 与 Set 用来存储数组类型的数据&lt;/p&gt;
&lt;h3 id=&#34;13-flutter项目配置文件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#13-flutter项目配置文件&#34;&gt;#&lt;/a&gt; 1.3 Flutter 项目配置文件&lt;/h3&gt;
&lt;p&gt;默认创建的 main.dart 就是 Flutter 项目的启动文件，main 函数就是程序启动入口，默认生成的 Flutter 页面是一个点击累加的计数器。&lt;/p&gt;
&lt;p&gt;pubspec 配置文件就是图 1-10 所示的⑱，该配置文件主要用来配置 Flutter 开发的一些依赖，&lt;/p&gt;
&lt;p&gt;environment 就是配置的当前项目的 Dart Sdk 开发环境&lt;/p&gt;
&lt;p&gt;属性 dependencies 之下就是配置依赖库这些信息了&lt;/p&gt;
&lt;p&gt;依赖库有两种，一种是纯 Dart 语言库，一种是插件类型的，包括 Android、iOS 双平台的内容。&lt;/p&gt;
&lt;p&gt;自定义的静态资源目录&lt;/p&gt;
&lt;p&gt;assets 文件夹名称可以自定义，此处根据 Android、iOS 原生习惯定义为 assets。&lt;/p&gt;
&lt;h3 id=&#34;14-flutter-app的调试技巧&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#14-flutter-app的调试技巧&#34;&gt;#&lt;/a&gt; 1.4 Flutter APP 的调试技巧&lt;/h3&gt;
&lt;p&gt;Flutter 项目的中的日志分为两类&lt;/p&gt;
&lt;p&gt;一类是 Android 原生与 iOS 原生中输出的日志信息&lt;/p&gt;
&lt;p&gt;一类是从 Dart 项目中输入的日志信息&lt;/p&gt;
&lt;p&gt;Flutter 有三种运行模式：Debug、Release、Profile，&lt;/p&gt;
&lt;p&gt;build 的时候是完全独立的&lt;/p&gt;
&lt;p&gt;Debug 模式可以在真机和模拟器上同时运行：会打开所有的断言，包括 debugging 信息、debugger aids（比如 observatory）和服务扩展，&lt;/p&gt;
&lt;p&gt;Release 模式只能在真机上运行&lt;/p&gt;
&lt;p&gt;这个模式是为了部署给最终用户使用的。命令 flutter run–release 就是以这种模式运行的。&lt;/p&gt;
&lt;p&gt;Profile 模式只能在真机上运行&lt;/p&gt;
&lt;p&gt;保留一些调试功能来配置应用程序的性能&lt;/p&gt;
&lt;p&gt;断点调试就是在每一行代码处打个断点，然后使用程序阻塞在断点处不执行，再调度该处对应的数据与逻辑&lt;/p&gt;
&lt;p&gt;Flutter Inspector 视图定位工具，就是在程序运行时，通过点击手机屏幕上运行的视图，可快速自动定位到当前视图中 Widget 对应的那一行实现代码，这个功能在大型项目中（一般有大量的代码块积累）非常适用，可以极大程度地节省开发者定位代码的时间消耗，由原来的手动检索代码过渡到现在的自动定位代码。&lt;/p&gt;
&lt;p&gt;Flutter Performance 内存管理工具可以实时跟踪应用程序的内存消耗&lt;/p&gt;
&lt;p&gt;退出这个页面后，内存用量没有下降，这就表明有内存泄漏&lt;/p&gt;
&lt;h2 id=&#34;第二章基础组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第二章基础组件&#34;&gt;#&lt;/a&gt; 第二章：基础组件&lt;/h2&gt;
&lt;p&gt;对于 Flutter 应用程序来讲，则是由若干个 Widget 组合起来的，它们组合到一起，形成一个 Widgets 树形结构，类似 dom 树&lt;/p&gt;
&lt;h3 id=&#34;21-materialapp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#21-materialapp&#34;&gt;#&lt;/a&gt; 2.1 MaterialApp&lt;/h3&gt;
&lt;p&gt;MaterialApp 组件是 Material Design 设计风格在 Flutter 中的体现，常用于开发 Material Design 设计风格的 APP&lt;/p&gt;
&lt;p&gt;MaterialApp 组件常用在 Widgets 树结构的顶层，或者可以理解为用来构建应用的根布局&lt;/p&gt;
&lt;p&gt;在 Android 原生开发中，要打开一个新的页面，先初始化一个 Intent，绑定目标页面的 class，然后调用 Context 的 startActivity 方法。&lt;/p&gt;
&lt;p&gt;打开一个新的页面有两种方式，一种是静态路由，一种是动态路由。&lt;/p&gt;
&lt;p&gt;静态路由&lt;/p&gt;
&lt;p&gt;routes 配置的是一个 Map，这个 Map 中 key 对应路由名称。value 对应路由页面&lt;/p&gt;
&lt;p&gt;通过 Navigator 的 pushNamed 方法打开对应的页面&lt;/p&gt;
&lt;p&gt;动态路由不通过 routes 配置，无指定的路由名字，在使用时直接使用 Navigator 来打开&lt;/p&gt;
&lt;p&gt;要退出当前 Widget 页面，有三种方式&lt;/p&gt;
&lt;p&gt;第一种是点击手机的返回按钮&lt;/p&gt;
&lt;p&gt;第二种是点击页面 AppBar 中默认的左上角的返回箭头&lt;/p&gt;
&lt;p&gt;第三种就是在页面中通过 Navigator 的 pop 方法&lt;/p&gt;
&lt;p&gt;将页面推出路由栈&lt;/p&gt;
&lt;p&gt;如果需要回传参数，可以直接写在 pop 方法中&lt;/p&gt;
&lt;p&gt;在回传数据与接收数据的地方，数据类型要保持一致&lt;/p&gt;
&lt;p&gt;需要注意在关闭当前页面时，最好判断一下当前页面是否是页面栈中的最后一个页面，也就是 Widgets 树中的最后一个 Widget，如果是的话，再强行执行 pop 方法，那么栈中就会无 Widget 页面，导致页面黑屏&lt;/p&gt;
&lt;p&gt;如果需要获取第二个页面关闭时回传到第一个页面的数据，可以使用 then 函数&lt;/p&gt;
&lt;p&gt;B 页面中获取 A 页面传递的数据需要在 didChangeDependencies 生命周期中获取&lt;/p&gt;
&lt;p&gt;因为这里使用了 context，所以不能在 initState 方法中获取，原因是在 initState 中 context 还未绑定成功。&lt;/p&gt;
&lt;p&gt;在动态路由中传值就比较方便了，可直接通过构造函数传值&lt;/p&gt;
&lt;p&gt;home 属性配置的 MyHomePage 就是当前 Flutter 应用启动加载的第一个 Flutter 页面。&lt;/p&gt;
&lt;p&gt;配置 Flutter 启动页面的方式二是在 MaterialApp 组件的属性 routes 中配置 “/”，然后指向需要默认打开的页面&lt;/p&gt;
&lt;p&gt;方式三是在 MaterialApp 组件的 initialRoute 属性中指定初始化打开的页面对应的路由&lt;/p&gt;
&lt;p&gt;initialRoute 指定的是静态路由的名称，这个名称需要在 routes 中配置后才能使用，&lt;/p&gt;
&lt;p&gt;这三种方式是互斥的，只允许单独配置使用&lt;/p&gt;
&lt;p&gt;配置 Flutter 默认启动页面的总结如下。&lt;/p&gt;
&lt;p&gt;通过 MaterialApp 的 home 属性来配置&lt;/p&gt;
&lt;p&gt;在 MaterialApp 的 routes 属性中配置 “/”&lt;/p&gt;
&lt;p&gt;通过 MaterialApp 的 initialRoute 属性&lt;/p&gt;
&lt;p&gt;如果需要配置为中文显示，首先需要添加 Flutter 应用的多语言功能支持。在配置文件 pubspec.yaml 中添加 localizations 多语言环境支持&lt;/p&gt;
&lt;p&gt;根布局视图下的 MaterialApp 组件中设置中文语言环境&lt;/p&gt;
&lt;p&gt;ThemeData 是在 Flutter 中对各组件样式的封装&lt;/p&gt;
&lt;p&gt;取值可为 ThemeMode.system 跟随当前系统的主题色&lt;/p&gt;
&lt;p&gt;primarySwatch 属性可以理解为一个基本的主要的配色设定&lt;/p&gt;
&lt;p&gt;primaryColor 可以理解为用来配置主颜色，AppBar 标题栏、TabBar 等一般是一个 Widget 页面的头，&lt;/p&gt;
&lt;p&gt;accentColor 可理解为引人注意的颜色，也可以理解为当前活跃的颜色，如 TabBar 的 indicator 指示线的颜色、开关 Switch 被选中后显示的高亮颜色等。&lt;/p&gt;
&lt;p&gt;highlightColor 是高亮颜色，如按下 Button 时显示的高亮颜色。&lt;/p&gt;
&lt;p&gt;splashColor 是点击反馈水波纹效果的颜色配置，例如点按 Button 显示的水波纹扩散的颜色。&lt;/p&gt;
&lt;h3 id=&#34;22-scaffold组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#22-scaffold组件&#34;&gt;#&lt;/a&gt; 2.2 Scaffold 组件&lt;/h3&gt;
&lt;p&gt;Scaffold 可称为脚手架，一般通过它搭建页面的基本结构&lt;/p&gt;
&lt;p&gt;header 头部，或者称之为标题栏&lt;/p&gt;
&lt;p&gt;body 体，可称之为内容主体页面&lt;/p&gt;
&lt;p&gt;bottom 脚，可称之为页面的尾部，比如 bottomBar。&lt;/p&gt;
&lt;p&gt;对于 Scaffold 来讲，它实现了基本的 Material Design 设计结构，一般可以用作单页面的主结构&lt;/p&gt;
&lt;p&gt;前两者的不同是它可以指定一个 Label 来显示文本，同时也限制了子 Widget 为 Icon 类型，对应添加子 Widget 的方式已不是 child，而是封装成 icon 属性，&lt;/p&gt;
&lt;p&gt;Scaffold 的属性 drawer 用来配置左侧侧拉页面，属性 endDrawe 配置右侧侧拉页面。&lt;/p&gt;
&lt;p&gt;此处左侧图标占用的是 AppBar 的 leading 属性，右侧占用的是 actions 属性&lt;/p&gt;
&lt;p&gt;bottomNavigationBar 属性来配置页面底部导航栏&lt;/p&gt;
&lt;p&gt;fixed 限制的切换效果是在导航栏菜单切换时，图标和文字标题会有微微缩放的动画效果，对于 shifting 来讲，切换动画效果更明显，在 shifting 模式下，只有当前选中的 item 的图标与文字才会显示出来&lt;/p&gt;
&lt;p&gt;也可以结合 BottomAppBar、TabBar 和 TabBarView 这样的组合来实现常见的首页底部菜单栏切换页面功能&lt;/p&gt;
&lt;p&gt;使用 BottomAppBar 组件可以自定义任意的子组件来实现菜单栏，在这里使用的是 TabBar 结合 Tab 的方式&lt;/p&gt;
&lt;h3 id=&#34;23-appbar&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#23-appbar&#34;&gt;#&lt;/a&gt; 2.3 AppBar&lt;/h3&gt;
&lt;p&gt;AppBar 组件的 title 属性是一个 Widget 类型，这就意味着可以定义任意的 Widget。&lt;/p&gt;
&lt;h3 id=&#34;24-文本显示text组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#24-文本显示text组件&#34;&gt;#&lt;/a&gt; 2.4 文本显示 Text 组件&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，Text 组件用于显示文本&lt;/p&gt;
&lt;p&gt;可以通过设置 Text 组件的 softWrap 属性来控制其是否自动换行&lt;/p&gt;
&lt;p&gt;TextStyle 中的 decoration 属性可用来配置文本中的下画线、删除线等装饰&lt;/p&gt;
&lt;p&gt;在 Flutter 中，使用 RichText 实现一段文本中多种文字风格的功能，类似 Android 中的 SpannableString 与 iOS 中的 NSMutableAttributedString。&lt;/p&gt;
&lt;p&gt;TextSpan 可以通过 children 属性来无限嵌套使用。使用此原理可开发一个用于显示搜索内容高亮颜色的依赖库 flutter_tag_layout，实际业务场景中就是搜索框搜索出的列表显示内容中有与关键字相同的内容就使用高亮颜色显示。&lt;/p&gt;
&lt;h3 id=&#34;25-文本输入框textfield组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#25-文本输入框textfield组件&#34;&gt;#&lt;/a&gt; 2.5 文本输入框 TextField 组件&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，组件 TextField 用来输入文本&lt;/p&gt;
&lt;p&gt;autofocus 用来配置是否自动获取输入焦点&lt;/p&gt;
&lt;p&gt;当页面中有 TextField 输入框时，手机键盘会自动弹出。&lt;/p&gt;
&lt;p&gt;TextField 默认情况下是有一个底部边框效果的，在实际项目开发中，是满足不了设计需要的。通过属性 decoration 配置 InputDecoration 可以定义更多效果&lt;/p&gt;
&lt;p&gt;通过 TextEditingController 可实现为绑定的输入框 TextField 预设内容、获取 TextField 中输入的内容、监听 TextField 中的文字输入变化等。&lt;/p&gt;
&lt;p&gt;EditingControlldr 也可以添加一个 Listener 监听，在当前的文本输入框 TextField 获取或者失去焦点、有文本输入时可监听到变化&lt;/p&gt;
&lt;p&gt;FocusNode 可以用来捕捉欲监听 TextField 的焦点，同时也可通过 FocusNode 来控制对应的 TextField 的焦点&lt;/p&gt;
&lt;p&gt;在实际项目中的一个用户操作习惯就是：当输入键盘是弹出状态时，用户点击屏幕的空白处，键盘要隐藏。实现思路就是在 MaterialApp 组件中的第一个根布局中设置一个手势监听，然后在手势监听中处理隐藏键盘的功能&lt;/p&gt;
&lt;h3 id=&#34;26-容器container组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#26-容器container组件&#34;&gt;#&lt;/a&gt; 2.6 容器 Container 组件&lt;/h3&gt;
&lt;p&gt;Container 组件是用来放置 widget 的容器，可以设置 padding、margin、位置、大小、边框和阴影等参数。&lt;/p&gt;
&lt;p&gt;Content（内容）：盒子的主内容区域，通过 child 属性来配置&lt;/p&gt;
&lt;p&gt;Container 可实现多种多样的装饰效果，如圆角边框、渐变背景、体育场背景等&lt;/p&gt;
&lt;p&gt;decoration 最常用的就是 BoxDecoration 盒模型装饰&lt;/p&gt;
&lt;h3 id=&#34;27-按钮button&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#27-按钮button&#34;&gt;#&lt;/a&gt; 2.7 按钮 Button&lt;/h3&gt;
&lt;p&gt;MaterialButton 是 Material Design 风格按钮，需要在 MaterialApp 组件中使用，它常用的按钮子类有 RaisedButton、FlatButton、OutlineButton。&lt;/p&gt;
&lt;h3 id=&#34;28-图片image组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#28-图片image组件&#34;&gt;#&lt;/a&gt; 2.8 图片 Image 组件&lt;/h3&gt;
&lt;p&gt;在 Flutter 中用来加载图片的组件有 AssetImage、DecorationImage、ExactAssetImage、FadeInImage、FileImage、NetworkImage、RawImage、MemoryImage、Image 等&lt;/p&gt;
&lt;p&gt;通过 Image.network 来加载网络图片，只需要传入对应的网络图片链接就可以&lt;/p&gt;
&lt;p&gt;也可以通过 NetworkImage 来配合 Image 加载网络图片&lt;/p&gt;
&lt;p&gt;在 Flutter 中，通过 Image.asset 来加载资源目录下的图片&lt;/p&gt;
&lt;h2 id=&#34;第三章布局&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第三章布局&#34;&gt;#&lt;/a&gt; 第三章：布局&lt;/h2&gt;
&lt;h3 id=&#34;31-线性布局column与row&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#31-线性布局column与row&#34;&gt;#&lt;/a&gt; 3.1 线性布局 Column 与 Row&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，使用 Row 和 Column 组件来实现水平或垂直方向的布局，Row 组件处理水平方向的布局，Column 组件处理垂直方向的布局。&lt;/p&gt;
&lt;p&gt;Row 和 Column 都有两根轴，MainAxisAlignment（主轴）和 CrossAxisAlignment（交叉轴）&lt;/p&gt;
&lt;p&gt;对于 Column 组件来讲，其作用是将子 Widget 在垂直方向线性排列，所以它的主轴就是垂直方向，水平方向就是它的交叉轴。对于 Row 来讲，其主轴就是水平方向，交叉轴就是垂直方向。&lt;/p&gt;
&lt;p&gt;主轴方向是填充&lt;/p&gt;
&lt;p&gt;交叉轴上是包裹&lt;/p&gt;
&lt;p&gt;当 Column 与 Row 的父布局有了宽高的限制后，Column 与 Row 在主轴与交叉轴方向上都是填充父布局的&lt;/p&gt;
&lt;p&gt;Column 与 Row 在主轴方向都是将子 Widget 以开始的位置对齐，在交叉轴方向都是居中对齐。&lt;/p&gt;
&lt;p&gt;结合 Expanded 组件使用后，第二个 Button 填充了水平方向剩余的所有的空白区域&lt;/p&gt;
&lt;p&gt;如果想要 Column 三个子 Widget 的高度相等，并且平均分配 Column 的空间，可结合 Expanded 组件来实现这种效果&lt;/p&gt;
&lt;p&gt;此处通过 Expanded 中配置的 flex 值，来决定子当前 Expanded 的子 Widget 占用的 height&lt;/p&gt;
&lt;p&gt;如在此处的三个区域内容中，Expanded 分别配置 flex 为 1，也就是会将当前 Column 的高度 height 平均分配成 3 份，然后每个子 Widget 占用一份，也就达到了等比分布的需求。&lt;/p&gt;
&lt;h3 id=&#34;32-非线性布局&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#32-非线性布局&#34;&gt;#&lt;/a&gt; 3.2 非线性布局&lt;/h3&gt;
&lt;p&gt;帧布局又可称为层叠布局，是将子 Widget 重叠在一起&lt;/p&gt;
&lt;p&gt;类似 Android 中的 Frame 布局&lt;/p&gt;
&lt;p&gt;Flutter 中弹性布局 Flex 的思想源于层叠样式表（Cascading Style Sheets，CSS）中。&lt;/p&gt;
&lt;p&gt;Column 继承于 Flex，配置 Flex 的 direction 属性为 Axis.vertical，Row 继承于 Flex，配置 Flex 的 direction 属性为 Axis. Horizontal。&lt;/p&gt;
&lt;p&gt;通过 Wrap 和 Flow 来支持流式布局，溢出部分则会自动折行&lt;/p&gt;
&lt;p&gt;对于 Flow 来讲，它能实现流式布局 Wrap 所实现的所有功能，它可以自定义任何布局的样式&lt;/p&gt;
&lt;h3 id=&#34;33-实现一个酷炫的登录页面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#33-实现一个酷炫的登录页面&#34;&gt;#&lt;/a&gt; 3.3 实现一个酷炫的登录页面&lt;/h3&gt;
&lt;p&gt;KeyboardPlaceholderWidget 是自定义封装的一个 Widget，这个组件的作用就是用来占位，它可以监听键盘的弹出与隐藏&lt;/p&gt;
&lt;h2 id=&#34;第四章功能性组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第四章功能性组件&#34;&gt;#&lt;/a&gt; 第四章：功能性组件&lt;/h2&gt;
&lt;h3 id=&#34;41-indicator&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#41-indicator&#34;&gt;#&lt;/a&gt; 4.1 Indicator&lt;/h3&gt;
&lt;p&gt;LinearProgressIndicator 是一个线性进度指示器 Widget&lt;/p&gt;
&lt;p&gt;当 value 为 null 时，进度条是一个线性的循环模式，表示正在加载；&lt;/p&gt;
&lt;p&gt;CircularProgressIndicator 是一个圆形循环的进度指示器 Widget，&lt;/p&gt;
&lt;h3 id=&#34;42-单选框radio-复选框checkbox-开关switch&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#42-单选框radio-复选框checkbox-开关switch&#34;&gt;#&lt;/a&gt; 4.2 单选框 Radio、复选框 CheckBox、开关 Switch&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，通过 Radio 组件来实现单选框效果&lt;/p&gt;
&lt;p&gt;RadioListTile 是一个用于便捷、快速构建列表样式的组件布局&lt;/p&gt;
&lt;p&gt;Switch 组件是 Material Design 设计风格的开关，CupertinoSwitch 是苹果设计风格的开关&lt;/p&gt;
&lt;h3 id=&#34;43-手势处理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#43-手势处理&#34;&gt;#&lt;/a&gt; 4.3 手势处理&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，提供的 Button 系列组件自带手势识别功能，如监听用户的点击与长按，都会有相应的事件回调，然后开发者可以在相应的回调函数中处理响应操作逻辑。&lt;/p&gt;
&lt;p&gt;GestureDetector 的 onTap 方法监听的是手指抬起时的回调&lt;/p&gt;
&lt;p&gt;通过 InkWell 添加点击事件会有点击高亮以及水波纹效果，而通过 GestureDetector 实现的点击无点击效果出现&lt;/p&gt;
&lt;p&gt;实际项目开发中，通常只是普通的点击事件建议使用 InkWell 组件&lt;/p&gt;
&lt;p&gt;Ink 常与 InkWell 和 InkResponse 一起使用，用来配置点击效果的水波纹与高亮的样式，Ink 必须在 Material Design 风格下进行使用，所以一般使用 Material 组件配合 Ink 来使用&lt;/p&gt;
&lt;h2 id=&#34;第五章滑动视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第五章滑动视图&#34;&gt;#&lt;/a&gt; 第五章：滑动视图&lt;/h2&gt;
&lt;p&gt;在 Flutter 中，通过 ScrollView 组件来实现滑动视图效果，当 ScrollView 的内容大于其本身 size 的时候，ScrollView 会自动添加滚动条，并可以竖直滑动&lt;/p&gt;
&lt;h3 id=&#34;51-scrollview&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#51-scrollview&#34;&gt;#&lt;/a&gt; 5.1 ScrollView&lt;/h3&gt;
&lt;p&gt;默认情况下，ScrollView 在竖直方向上下滑动&lt;/p&gt;
&lt;p&gt;可通过 physics 属性来修改为指定的效果&lt;/p&gt;
&lt;p&gt;SingleChildScrollView 适用于简单滑动视图处理，如 APP 中常见的商品详情页面、订单详情页面&lt;/p&gt;
&lt;p&gt;在 ScrollController 中可添加监听，然后实时获取滚动的距离，从而判断是否滚动到了顶部或者是底部，然后进行一些业务上的需求开发&lt;/p&gt;
&lt;p&gt;NestedScrollView 继承于 CustomScrollView，它比 SingleChildScrollView 更强大，可以用来实现诸如滑动折叠头部的功能，基本使用代码如下&lt;/p&gt;
&lt;p&gt;当一个页面中，既有九宫格布局 GridView 又有列表 ListView，二者有各自的滑动区域，不能进行统一滑动，可通过 CustomScrollView 将二者结合起来&lt;/p&gt;
&lt;p&gt;宫格布局 SliverGrid&lt;/p&gt;
&lt;p&gt;SliverGridDelegateWithFixedCrossAxisCount，这个 delegate 是用来根据指定的每行显示多少列 Item，而依次换行显示，不同屏幕分辨率下的手机显示的列数是一样&lt;/p&gt;
&lt;p&gt;SliverGridDelegateWithMaxCrossAxisExtent，这个 delegate 是根据每个 Item 允许的最大宽度然后依次排列每个 Item，也就是不同屏幕分辨率下的手机显示的列数不一样&lt;/p&gt;
&lt;p&gt;SliverChildListDelegate 用来构建少量 Item 的应用场景，在使用这个 delegate 时，会将使用到的 Item 一次性构建出来。&lt;/p&gt;
&lt;p&gt;SliverChildBuilderDelegate 用来构建大量 Item 的应用场景，在使用时，只会构建手机屏幕上显示的 Item，不会构建屏幕以外未显示的 Item，所以是懒加载方式。&lt;/p&gt;
&lt;h3 id=&#34;52-pageview&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#52-pageview&#34;&gt;#&lt;/a&gt; 5.2 PageView&lt;/h3&gt;
&lt;p&gt;PageView 可用于 Widget 的整屏滑动切换，如当下流行的短视频 APP 中的上下滑动切换功能，也可用于横向页面的切换，如 APP 第一次安装时的引导页面，也可用于开发轮播图功能&lt;/p&gt;
&lt;h3 id=&#34;53-listview与gridview&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#53-listview与gridview&#34;&gt;#&lt;/a&gt; 5.3 ListView 与 GridView&lt;/h3&gt;
&lt;p&gt;ListView 是最常用的可滚动列表，GridView 用来构建二维网格列表，两者都继承自 BoxScrollView&lt;/p&gt;
&lt;p&gt;ListView 有 4 种创建方式，描述如下&lt;/p&gt;
&lt;p&gt;默认构造函数（传入 List children）&lt;/p&gt;
&lt;p&gt;通过 ListView.builder 方式来创建，适用于有大量数据的情况&lt;/p&gt;
&lt;p&gt;通过 ListView.custom 方式来构建，提供了自定义子 Widget 的能力。&lt;/p&gt;
&lt;p&gt;通过 ListView.separated 方式来创建，可以配置分割线，适用于具有固定数量列表项的 ListView。&lt;/p&gt;
&lt;p&gt;实际项目业务开发中，第二种方式使用得比较多，通常称为懒加载模式，适合列表项比较多的情况，因为只有当子组件真正显示的时候才会被创建&lt;/p&gt;
&lt;p&gt;ListView.separated 可以在生成的列表项之间添加一个分割组件，它比 ListView.builder 多了一个 separatorBuilder 参数，该参数是一个分割组件生成器，常用于列表 Item 之间有分隔线的场景&lt;/p&gt;
&lt;p&gt;GridView 创建方法有五种，描述如下。&lt;/p&gt;
&lt;p&gt;GridView 构造函数方法，一次性构建所有子条目，适用于少量数据。&lt;/p&gt;
&lt;p&gt;GridView.builder 方式来构建，懒加载模式，适用于大量数据的情况。&lt;/p&gt;
&lt;p&gt;GridView.count 方式来构建，适用于固定列的情况，适用于少量数据。&lt;/p&gt;
&lt;p&gt;GridView.extent 方式来构建，适用于条目有最大宽度限制的情况，适用于少量数据的情况。&lt;/p&gt;
&lt;p&gt;GridView.custom 方式来构建，可配置子条目的排列规则，也可配置子条目的渲染加载模式。&lt;/p&gt;
&lt;p&gt;下拉刷新与上拉加载更多 RefreshIndicator 是 Material 风格的滑动刷新 Widget，在 ListView 与 GridView 的外层直接嵌套使用即可&lt;/p&gt;
&lt;h2 id=&#34;第六章动画&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第六章动画&#34;&gt;#&lt;/a&gt; 第六章：动画&lt;/h2&gt;
&lt;h3 id=&#34;61-基本动画&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#61-基本动画&#34;&gt;#&lt;/a&gt; 6.1 基本动画&lt;/h3&gt;
&lt;p&gt;通过 AnimatedOpacity 组件可实现基本的透明度变化动画，适用于简单过渡业务场景&lt;/p&gt;
&lt;h3 id=&#34;63-其他动画概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#63-其他动画概述&#34;&gt;#&lt;/a&gt; 6.3 其他动画概述&lt;/h3&gt;
&lt;p&gt;Android、iOS、JS、Flutter 中都可以使用 Canvas 画布结合 Path 路径来绘制任意想要的自定义图形，再结合动画，就可以实现更加酷炫的效果&lt;/p&gt;
&lt;p&gt;在 Flutter 中，通过 PathMetric 来度量完整的 Path 路径，PathMetric 可以获取完整的 Path 路径下任意一截的数据，形成新的 Path 路径。&lt;/p&gt;
&lt;h2 id=&#34;第七章弹框&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第七章弹框&#34;&gt;#&lt;/a&gt; 第七章：弹框&lt;/h2&gt;
&lt;h3 id=&#34;71-基本弹框的使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#71-基本弹框的使用&#34;&gt;#&lt;/a&gt; 7.1 基本弹框的使用&lt;/h3&gt;
&lt;p&gt;showDialog 方法是 Material 组件库提供的一个用于弹出 Material 风格弹框的方法&lt;/p&gt;
&lt;p&gt;SimpleDialog 是一个适用于有列表排列的弹框选项的情况&lt;/p&gt;
&lt;p&gt;showGeneralDialog 方法用来完全自定义显示的弹框内容&lt;/p&gt;
&lt;p&gt;showBottomSheet 用来在视图底部弹出一个 Material Design 风格的对话框&lt;/p&gt;
&lt;p&gt;showModalBottomSheet 用来在视图底部弹出一个 Modal Material Design 风格的对话框&lt;/p&gt;
&lt;h3 id=&#34;72-dialog中的状态更新&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#72-dialog中的状态更新&#34;&gt;#&lt;/a&gt; 7.2 Dialog 中的状态更新&lt;/h3&gt;
&lt;p&gt;AlertDialog 中使用到了单选框，点击切换时却发现是无法切换选项的，原因是在弹出的弹框构建出新的 StatelessWidget，与当前页面的 StatefulWidget 或者 StatelessWidget 是平级的，直接使用 setState 是调用当前页面的更新操作，而未调用到新的 StatelessWidget 中对应的 State。&lt;/p&gt;
&lt;p&gt;解决方案一就是将弹框中需要更新状态的内容单独封装&lt;/p&gt;
&lt;p&gt;解决方式二就是结合 StatefulBuilder 来实现&lt;/p&gt;
&lt;h2 id=&#34;第八章绘图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第八章绘图&#34;&gt;#&lt;/a&gt; 第八章：绘图&lt;/h2&gt;
&lt;p&gt;在 Flutter 中，绘图需要用到 CustomPaint 和 CustomPainter，CustomPainter 可理解为画板，用来承载画布，CustomPaint 可理解为画布，承载绘制的具体内容。&lt;/p&gt;
&lt;h3 id=&#34;83-贝塞尔曲线&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#83-贝塞尔曲线&#34;&gt;#&lt;/a&gt; 8.3 贝塞尔曲线&lt;/h3&gt;
&lt;p&gt;个点构成一个基本的直线，可称为一阶贝塞尔曲线&lt;/p&gt;
&lt;p&gt;这两个点之间的线段被一个其他的点牵引后，形成曲线，如图 8-13 所示称为二阶贝塞尔曲线&lt;/p&gt;
&lt;h2 id=&#34;第九章插件开发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第九章插件开发&#34;&gt;#&lt;/a&gt; 第九章：插件开发&lt;/h2&gt;
&lt;p&gt;在 Flutter 中，插件类型分为三种：Flutter Plugin、Flutter Package、Flutter Module&lt;/p&gt;
&lt;p&gt;对于 Flutter Plugin，在 Flutter 中使用 Dart 语言开发移动应用，一套代码可以同时适用 Android 和 iOS 两种环境，但是 Dart 不会编译成 Android Dalvik 字节码，在 iOS 上也不会有 Dart/Objective-C 的绑定，也就是意味着 Dart 代码并不会直接访问平台特定的 API，即 iOS Cocoa Touch 以及 Android SDK 的 API。&lt;/p&gt;
&lt;p&gt;开发插件包是用来开发调用特定平台的 API 包，这个插件包包含针对 Android（Java 或 Kotlin 代码）或 iOS（Objective-C 或 Swift 代码）编写的特定于平台的功能实现（可以同时包含 Android 和 iOS 原生的代码），如加载 H5 的 WebView、调用自定义相机、录音、蓝牙等。&lt;/p&gt;
&lt;h3 id=&#34;91-flutter与原生android-ios双向通信&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#91-flutter与原生android-ios双向通信&#34;&gt;#&lt;/a&gt; 9.1 Flutter 与原生（Android、iOS）双向通信&lt;/h3&gt;
&lt;p&gt;所谓双向通信，此处是指在 Flutter 中调用 Android 与 iOS，以及在原生 Android 与 iOS 中调用 Flutter，也就是数据的双向传输。&lt;/p&gt;
&lt;p&gt;常用的 Flutter 与 Android、iOS 原生的通信有以下三种方式。 1）BasicMessageChannel 用于传递字符串和半结构化的信息。 2）MethodChannel 用于传递方法调用，当然也可传输参数。 3）EventChannel 用于数据流 Event Streams 的通信。&lt;/p&gt;
&lt;p&gt;对于 MethodChannel，官方 API 中解析为 “A named channel for communicating with platform plugins using asynchronous method calls…”，也就是用来实现 Flutter 与原生 Android、iOS 通信。&lt;/p&gt;
&lt;p&gt;在实际项目开发中，可以考虑全局注册使用一个 MethodChannel 就好&lt;/p&gt;
&lt;p&gt;Flutter 项目中，Android 目录下的 MainActivity 就是对应的启动 Activity，可以直接在 MainActivity 中设置方法监听&lt;/p&gt;
&lt;p&gt;对应的 getMethodCallHandler 方法就是通过匿名内部类的方式创建一个 MethodCallHandler 回调对象&lt;/p&gt;
&lt;p&gt;这里从 Flutter 发送数据到 Android 中，发送的数据格式要与 Android 中接收的数据类型一致&lt;/p&gt;
&lt;p&gt;对于 BasicMessageChannel，也可用来实现 Flutter 与原生 Android、iOS 通信，与 MethodChannel 的区别是 MethodChannel 针对于方法调用使用，BasicMessageChannel 针对于消息数据来使用&lt;/p&gt;
&lt;p&gt;在 Flutter 应用项目的 Android 目录下的 MainActivity 中，一是要接收 Flutter 中发送过来的消息并做出回应消息，二是要主动多次地向 Flutter 中发送消息&lt;/p&gt;
&lt;p&gt;也可通过 BasicMessageChannel 来主动向 Flutter 中发送消息，代码如下&lt;/p&gt;
&lt;p&gt;当在 Android 中注册了 EventChannel 消息通道后，可通过 EventChannel.EventSink 向 Flutter 中发送消息&lt;/p&gt;
&lt;p&gt;EventChannel 通道适用于频繁发送消息的情景，此处使用定时器模拟实时传输数据的情况&lt;/p&gt;
&lt;h2 id=&#34;第十章进阶&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第十章进阶&#34;&gt;#&lt;/a&gt; 第十章：进阶&lt;/h2&gt;
&lt;h3 id=&#34;101-异步编程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#101-异步编程&#34;&gt;#&lt;/a&gt; 10.1 异步编程&lt;/h3&gt;
&lt;p&gt;在 Flutter 开发中，使用 async 关键字开启一个异步开始处理，使用 await 关键字来等待处理结果&lt;/p&gt;
&lt;p&gt;这个结果通常是一个 Future 对象。Future 表示延迟计算的对象&lt;/p&gt;
&lt;p&gt;Future 用于表示将来某个时间可用的潜在值或错误，也就是用来处理异步结果。&lt;/p&gt;
&lt;p&gt;如处理一个网络请求，或者是加载一个图片、文件，需要异步加载，通过 async 与 await 的组合可以实现这个操作&lt;/p&gt;
&lt;p&gt;综上所述，串行调用两个异步任务的一般写法如下所示&lt;/p&gt;
&lt;p&gt;也可以用 Future 提供的 then 函数&lt;/p&gt;
&lt;p&gt;在 Flutter 中实现延时操作有两种方式，一种是通过 Future，另一种是通过 Timer&lt;/p&gt;
&lt;p&gt;Future 的 then 函数返回值类型为一个 Future 对象，所以支持链式调用，组合在一起就是串行方式调用&lt;/p&gt;
&lt;p&gt;假如在 then 函数中任何一个环节出现了异常，那么后续的函数将会被中断执行&lt;/p&gt;
&lt;p&gt;Future 的 whenComplete 方法，类似于 try-catch-finally 中的 finally 块，所以使用 whenComplete 来结束多个异步操作是一个合适的解决方案&lt;/p&gt;
&lt;p&gt;源码的角度来看，Future 中实现的延时操作也是通过 Timer 来实现的，在实际开发中，如果只是一个单纯的延时操作，建议使用 Timer&lt;/p&gt;
&lt;p&gt;Future 用来处理异步操作结果，在注册回调时，通常的做法是分别注册两个回调，首先使用 then 和一个参数（值处理程序），然后使用第二个 catchError 处理错误。&lt;/p&gt;
&lt;p&gt;Flutter 的构造方法描述如下&lt;/p&gt;
&lt;p&gt;1）通过构造方法来创建&lt;/p&gt;
&lt;p&gt;2）创建一个延迟指定时间的异步任务&lt;/p&gt;
&lt;p&gt;3）创建一个错误回调，如在异步任务中判断为错误的结果时，可使用此方法&lt;/p&gt;
&lt;p&gt;4）microtask 方法用于将任务添加到主消息任务队列中，&lt;/p&gt;
&lt;p&gt;5）sync 方法用于将任务添加到当前的消息任务队列中&lt;/p&gt;
&lt;p&gt;6）value 方法用于将一个普通的计算结果构建成一个 Future 对象体。&lt;/p&gt;
&lt;p&gt;Future 的 doWhile 方法用来循环执行一定量的任务，可以是同步的任务也可以是异步的任务&lt;/p&gt;
&lt;p&gt;1）Timer 默认构造函数创建的是一个倒计时的功能（延时功能）&lt;/p&gt;
&lt;p&gt;2）Timer.periodic 创建的是一个间隔一定时间的计时器。&lt;/p&gt;
&lt;p&gt;3）静态方法 run 用来快速创建一个任务添加到当前任务队列中，相当于使用 Timer 默认构造创建的一个 Duration.zero 无延迟的任务执行。&lt;/p&gt;
&lt;p&gt;大部分操作系统（如 Windows、Linux）的任务调度是采用时间片轮转的抢占式调度方式&lt;/p&gt;
&lt;p&gt;任务执行的一小段时间叫作时间片，任务正在执行时的状态叫作运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来，任务的停与执行切换，称之为任务调度。&lt;/p&gt;
&lt;p&gt;操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），进程是资源分配的最小单位，也就是操作系统的最小单位。&lt;/p&gt;
&lt;p&gt;线程是进程中的概念，一个进程中可包含多个线程，任务调度采用的是时间片轮转的抢占式调度方式，进程是任务调度的最小单位。默认情况下，一般一个进程里只有一个线程，进程本身就是线程，所以线程可以被称为轻量级进程。&lt;/p&gt;
&lt;p&gt;协程是一种基于线程，但又是比线程更加轻量级的存在，是线程中的概念，一个线程可以拥有多个协程。&lt;/p&gt;
&lt;p&gt;传统的 J2EE 体系中，都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务），所以系统的吞吐能力取决于每个线程的操作耗时&lt;/p&gt;
&lt;p&gt;如果遇到很耗时的 I/O 行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多，会存在很多其他的线程在等待的情况，空闲状态（等待前面的线程执行完才能执行）造成了资源应用不彻底。&lt;/p&gt;
&lt;p&gt;最常见的例子就是同步阻塞的 JDBC&lt;/p&gt;
&lt;p&gt;连接过程中线程根本没有利用 CPU 去做运算，而是处在等待状态，而另外过多的线程，也会带来更多的 ContextSwitch（上下文切换）开销&lt;/p&gt;
&lt;p&gt;协程的作用下，当出现长时间的 I/O 操作时，协程通过让出当前占用的任务通道，执行下一个任务的方式，在线程中实现任务调度&lt;/p&gt;
&lt;p&gt;从编程角度上看，协程的思想本质上就是控制流的主动让出（Yield）和恢复（Resume）机制。&lt;/p&gt;
&lt;p&gt;点击 APP 图标启动时，手机操作系统会为当前 APP 创建一个进程&lt;/p&gt;
&lt;p&gt;Dart 是基于单线程模型的语言，所以在 Flutter 中，一般的异步操作实际上还是通过单线程通过调度任务优先级来实现的。&lt;/p&gt;
&lt;p&gt;Dart 中的线程机制被称为 isolate&lt;/p&gt;
&lt;p&gt;在 Flutter 项目中，运行中的 Flutter 程序由一个或多个 isolate 组成，默认情况下启动的 Flutter 项目，通过 main 函数启动就是创建了一个 main isolate，它 Flutter 的主线程，或者是 UI 线程。&lt;/p&gt;
&lt;p&gt;单线程模型中主要就是在维护着一个事件循环（Event Loop）与两个队列（event queue 和 microtask queue）。当 Flutter 项目程序触发如点击事件、I/O 事件、网络事件时，它们就会被加入 eventLoop 中，eventLoop 一直在循环之中，当主线程发现事件队列不为空时，就会取出事件，并且执行。&lt;/p&gt;
&lt;p&gt;microtask queue（主队列）只处理在当前 isolate 中的任务，优先级高于 event queue&lt;/p&gt;
&lt;p&gt;当事件正在循环处理 microtask 事件时，event queue（事件队列）会被堵塞。这时候 APP 就无法进行 UI 绘制，响应鼠标事件和 I/O 等事件。&lt;/p&gt;
&lt;p&gt;主队列和事件队列这两个任务队列中的任务切换机制与协程调度机制是一致的。&lt;/p&gt;
&lt;p&gt;Future 就是 event，每一个被 await 标记的句柄也是一个 event，timer 创建的任务也是一个 event，每创建一个 Future 就会把这个 Future 扔进 event queue 中排队。&lt;/p&gt;
&lt;p&gt;使用 Future 的 microtask 方法用于将任务添加到 microtask queue 任务队列中。&lt;/p&gt;
&lt;p&gt;FutureBuilder 用于将 Future 处理结果与 UI 数据刷新显示完美地结合在一起&lt;/p&gt;
&lt;p&gt;在构造 FutureBuilder 时，不能在 State.build 或 StatelessWidget.build 方法调用期间创建它，如果 Future 与 FutureBuilder 同时创建，那么每次重新构建 FutureBuilder 的父类时，都会重新启动异步任务。&lt;/p&gt;
&lt;h3 id=&#34;102-文件file的读写&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#102-文件file的读写&#34;&gt;#&lt;/a&gt; 10.2 文件 File 的读写&lt;/h3&gt;
&lt;p&gt;在 Flutter 工程项目中可以自定义资源文件的存储目录，如图 10-4 所示，只需要在配置文件中做好路径配置即可。&lt;/p&gt;
&lt;p&gt;每个 Flutter 应用程序都有一个默认创建的 rootBundle 对象，通过它可以轻松访问主资源包&lt;/p&gt;
&lt;p&gt;DefaultAssetBundle 来获取当前 BuildContext 的 AssetBundle。这种方法不是使用应用程序构建的默认 asset bundle，而是使父级 Widget 在运行时动态替换的不同的 AssetBundle，&lt;/p&gt;
&lt;p&gt;Dart 的 I/O 库包含了文件读写的相关类，所以对于文件的读写操作是需要导入 I/O 库。&lt;/p&gt;
&lt;p&gt;手机磁盘上的文件读写，首先要获取磁盘上开放的对应的目录空间，在这里使用插件 PathProvider 来实现这个操作&lt;/p&gt;
&lt;p&gt;临时目录：系统可随时清除的临时目录（缓存）。在 Android 上，对应 getCacheDir ()&lt;/p&gt;
&lt;p&gt;文档目录：对应 Android 的 AppData 目录&lt;/p&gt;
&lt;p&gt;在 Android 平台中，可以获取外部存储目录空间，iOS 则不支持&lt;/p&gt;
&lt;p&gt;File 文件存储适用于保存到这样的目录下，如应用程序必备的升级功能，需要将安装包数据先保存到文档目录中，再如音乐、视频一类的 APP，需要将媒体数据通过 File 保存到磁盘上&lt;/p&gt;
&lt;p&gt;还有一些轻量级的数据，如用户的基本信息、对应用的偏好设置信息，这些数据量小，权重也比较高，可以使用数据存储 SharedPreferences，需要在 pubspec.yaml 中添加相关依赖&lt;/p&gt;
&lt;p&gt;Sharedpreferences 是 Android 平台上一个轻量级的存储类，用来保存一些轻量级数据，如应用程序的各种配置信息，时以 “键 - 值” 对的方式（或者说是 key-value 的形式）保存数据的 xml 文件，其文件保存在 /data/data/ 应用包名 /shared_prefs 目录下&lt;/p&gt;
&lt;p&gt;需要注意的是，在使用 Sharedpreferences 时，首先是异步获取 Sharedpreferences 的实例&lt;/p&gt;
&lt;p&gt;针对列表数据，适合使用数据库来缓存。&lt;/p&gt;
&lt;p&gt;此处使用插件 sqflite 来实现这个操作&lt;/p&gt;
&lt;p&gt;在实际项目开发中，数据库可以在适当的一个版块业务结束后再关闭，或者是应用程序退出时再关闭，因为数据库的频繁打开与关闭也是一种性能消耗。&lt;/p&gt;
&lt;h3 id=&#34;103-网络请求库&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#103-网络请求库&#34;&gt;#&lt;/a&gt; 10.3 网络请求库&lt;/h3&gt;
&lt;p&gt;Dart I/O 库中提供了用于发起 Http 请求的一些类，可以直接使用 HttpClient 来发起请求&lt;/p&gt;
&lt;p&gt;Dio 是一个支持 Restful API、FormData、拦截器、请求取消、Cookie 管理、文件上传 / 下载、超时等功能的封装网络框架。&lt;/p&gt;
&lt;p&gt;Dio post 请求提交 FormData 表单数据，FormData 将提交的参数 name 与 value 进行组合，实现表单数据的序列化，从而减少表单元素的拼接。&lt;/p&gt;
&lt;p&gt;在应用开发中，会有像 token、appVersionCode 等这些每个接口请求都需要传的参数，称之为公共请求参数&lt;/p&gt;
&lt;p&gt;Dio 配置 Content-Type 与请求 header，创建 Dio 对象时，会初始化一个 BaseOptions 来创建 Dio，通过 BaseOptions 可以来设置请求头&lt;/p&gt;
&lt;p&gt;业务开发场景中，例如退出一个页面时，如果网络请求没完成，就会形成内存泄漏，所以需要在页面销毁时，取消网络请求，或者是在下载一个文件时，时间太长了，用户点击取消，就需要取消网络连接&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
