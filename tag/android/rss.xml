<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Marshwallen • Posts by &#34;android&#34; tag</title>
        <link>https://onlie202.github.io</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Thu, 14 Mar 2024 15:38:15 +0800</pubDate>
        <lastBuildDate>Thu, 14 Mar 2024 15:38:15 +0800</lastBuildDate>
        <category>Nginx</category>
        <category>Android</category>
        <category>Flutter</category>
        <category>Ubuntu</category>
        <category>Others</category>
        <item>
            <guid isPermalink="true">https://onlie202.github.io/2024/03/14/Android%E5%8E%9F%E7%94%9F/</guid>
            <title>Android原生</title>
            <link>https://onlie202.github.io/2024/03/14/Android%E5%8E%9F%E7%94%9F/</link>
            <category>Android</category>
            <pubDate>Thu, 14 Mar 2024 15:38:15 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;android原生相关知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#android原生相关知识&#34;&gt;#&lt;/a&gt; Android 原生相关知识&lt;/h1&gt;
&lt;h2 id=&#34;第一部分android-四大组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第一部分android-四大组件&#34;&gt;#&lt;/a&gt; 第一部分：Android 四大组件&lt;/h2&gt;
&lt;h3 id=&#34;1-activity&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-activity&#34;&gt;#&lt;/a&gt; 1、Activity&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 Activity 的生命周期？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整个生命周期： onCreate ()-&amp;gt;onStart ()-&amp;gt;onResume ()-&amp;gt;onPause ()-&amp;gt;onStop ()-&amp;gt;onDestory ()&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 Activity 的 4 种启动模式？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;四大启动模式：标准模式 Standard、栈顶复用模式 SingleTop、栈内复用模式 SingleTask、单例模式 SingleInstance&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请说下切换横竖屏时 Activity 的生命周期变化？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生命周期：onPause ()-&amp;gt;onSaveInstanceState ()-&amp;gt; onStop ()-&amp;gt;onDestroy ()-&amp;gt;onCreate ()-&amp;gt;onStart ()-&amp;gt;onRestoreInstanceState-&amp;gt;onResume ()&lt;/p&gt;
&lt;h3 id=&#34;2-service&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-service&#34;&gt;#&lt;/a&gt; 2、Service&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 Service 的启动方式，启动方式的区别？⭐⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Service 可以和其他的组件形成一定联系，通过传达信息来联系多个组件共同执行某个操作&lt;br&gt;
启动方式：startService () 和 bindService ()&lt;br&gt;
 区别：&lt;br&gt;
1、startService () 的生命周期不再受启动它的组件的影响，它可以在后台无限期地运行，直到 ServiceA 自己调用 stopSelf () 或者其他的组件手动调用 stopService (ServiceA) 时 ServiceA 才会停止&lt;br&gt;
 2、对于 bindService ()，当 Activity 调用 unBindService 或者 Activity 挂掉，则服务会停止&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 Service 的生命周期？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、startService () 生命周期顺序：onCreate-&amp;gt;onStartCommand-&amp;gt;onDestroy&lt;br&gt;
2、bindService () 生命周期顺序：onCreate-&amp;gt;onBind-&amp;gt;onUnBind-&amp;gt;onDestroy&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Activity、Service、intent 之间的联系？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Activity 负责用户交互界面的显示和交互逻辑的实现，Service 则负责后台任务的处理。而 Intent 意为 “意图”，像一座桥梁一样，负责 Activity 和 Service 之间的数据传递&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Activity 和 Service 中创建 Thread 的区别？（进阶题）⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、在 Activity 中创建：该线程负责完成该 Activity 的某个特殊任务，特别是耗时的任务，等 Activity 被销毁后，线程就没有生存的意义了，也应该销毁&lt;br&gt;
 2、在 Service 中创建：一般在 Service 的线程是为了长期存在于后台，完成某种特殊任务。只要服务没有挂掉，该线程就一直在后台跑。比如在 Service 中保持与服务器的长连接&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;android 进程的优先级？以及如何保证 Service 不被杀死？（进阶题）⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、优先级：&lt;br&gt;
（1）前台进程 -&amp;gt;&lt;br&gt;
（2）可见进程（对用户可见，但不能与用户交互的 Activity 或者绑定在其上面的 Service）-&amp;gt;&lt;br&gt;
（3）服务进程 -&amp;gt;&lt;br&gt;
（4）后台进程（运行着执行 onStop 方法而停止的程序）-&amp;gt;&lt;br&gt;
（5）空进程&lt;br&gt;
 2、保证 Service 不被杀死：&lt;br&gt;
（1）使用自定义系统服务：自定义系统服务原则上是不会被系统杀死的，因此，一些重要的服务可以考虑用自定义系统服务来实现&lt;br&gt;
（2）使用系统服务来监控：先弄一个白名单，记录需要监控的应用的包名，再自定义一个系统服务，监控系统里某个应用被杀死，如果该应用在白名单上，则重新拉起应用&lt;br&gt;
（3）等等&lt;/p&gt;
&lt;h3 id=&#34;3-broadcast&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-broadcast&#34;&gt;#&lt;/a&gt; 3、BroadCast&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 Android 里广播的分类？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;广播：广泛运用的在应用程序之间传输信息的机制。主要有两大角色：广播接收者和广播发送者&lt;br&gt;
类型：&lt;br&gt;
1、普通广播（Normal Broadcast）：完全异步执行的广播&lt;br&gt;
 2、系统广播（System Broadcast）：涉及系统基础操作&lt;br&gt;
 3、有序广播（Ordered Broadcast）：同步执行的广播，按广播接收者的优先级由高到低排序，轮流接收到广播&lt;br&gt;
 4、粘性广播（Sticky Broadcast）：Android5.0 之后已经废弃&lt;br&gt;
 5、本地广播（Local Broadcast）：用于应用内部传递消息，比 broadcastReceiver 更加高效和安全&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序 A 能否接收到程序 B 的广播？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要使用全局的 BroadCastRecevier 能进行跨进程通信，不过只能被动接收广播&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请列举广播注册的方式，并简单描述其区别？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、静态注册：在 AndroidManifest.xml 清单文件里直接声明&lt;br&gt;
 2、代码运行到了才注册广播。最好在 Activity 的 onResume () 注册、onPause () 注销。一旦忘记注销，那么就会造成内存泄露&lt;/p&gt;
&lt;h3 id=&#34;4-内容提供者&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-内容提供者&#34;&gt;#&lt;/a&gt; 4、内容提供者&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是内容提供者？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Intent 传递数据大小的限制大概在 1M 左右，超过这个限制就会静默崩溃。因此我们就可以通过 ContentProvider 进行进程间的数据传递，也就是 ContentProvider 是一种进程间的数据传递的方式&lt;br&gt;
 Android 数据存储的方式有：文件，数据库，网络，SharePreferences，ContentProvider&lt;br&gt;
ContentProvider 更准确来说只是一个中间者的身份，真正存储数据的是数据库和文件等形式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单介绍下 ContentProvider 是如何实现数据共享的（原理）？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;说说 ContentProvider、ContentResolver、ContentObserver 之间的关系？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、ContentProvider：内容提供者，主要作用就是管理数据，比如最常见的增删改查操作，同时为这些数据的访问提供了统一的接口（用 URL 实现），实现进程间的数据传递和共享&lt;br&gt;
 2、ContentResolver：内容解析者，ContentResolver 可以为不同 URI 操作不同的 ContentProvider 中的数据，外部进程可以通过 ContentResolver 与 ContentProvider 进行交互&lt;br&gt;
 3、ContentObserver：内容观察者，观察 ContentProvider 中的数据变化，有变化的时候执行特定操作。本人用的最多的是监听 Settings 数据库的变化。由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver () 去取消注册&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说说如何创建自己应用的内容提供者的使用场景。⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;说说 ContentProvider 的权限管理。⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读写分离，权限控制 - 精确到表级，URL 控制&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要使用通过 ContentResolver 类从而与 ContentProvider 类进行交互，而不直接访问 ContentProvider 类？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ContentResolver 统一管理不同 ContentProvider 间的操作。因为同一个进程可能有多个 ContentProvider，如果每一个都需要单独去管理，那么花费的成本自然很高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ContentProvider 的底层是采用 Android 中的 Binder 机制，既然已经有了 binder 实现了进程间通信了为什么还会需要 contentProvider？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、从架构层次看，为了降低业务层和数据层的耦合程度，我们希望数据访问层也可以有一个个独立的组件，对业务层提供统一调用接口，对数据层可以针对不同数据存储类型有不同的实现方式&lt;br&gt;
 2、从传输效率看，不同的进程可以通过 Binder、Intent 去传输数据，但如果数据量大的时候，就都不适用了。而 ContentProvider 进行数据传输的方式是采用匿名共享内存机制，众所周知，共享内存可以高效地传递大量数据&lt;/p&gt;
&lt;h2 id=&#34;第二部分android基础知识篇&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第二部分android基础知识篇&#34;&gt;#&lt;/a&gt; 第二部分：Android 基础知识篇&lt;/h2&gt;
&lt;h3 id=&#34;5-context&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-context&#34;&gt;#&lt;/a&gt; 5、Context&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;谈谈你对 Activity 的 Context 的认识？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、安卓的应用模型是基于组件的应用设计模式，比如 Activity 和 Service 这些组件在运行的时候，都需要一个完整的 Android 工程环境。那么在代码里，这个 “环境” 由谁提供？那自然就是 Context 类&lt;br&gt;
 2、只有 Activity 需要指定主题，而 Service 和 Application 是不需要使用主题的。因此才有 Actvity 继承 ContextThemeWrapper，而 Service 和 Application 直接继承 ContextWrapper。ContextThemeWrapper 继承 ContextWrapper 继承 Context&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Application 和 Activity, Context 的区别？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;getApplication () 和 getApplicationContext () 的区别？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取 Context 的方法&lt;br&gt;
返回的结果是同样的结果，但 getApplication () 是获取应用实例，只有在 Activity 和 Service 中可以调用，而 getApplicationContext () 含义是为了获取的是整个应用程序的工程环境，可以在 Broadcast Receiver 和 Content Provider 中调用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;context 错误用法有哪些？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如何正确使用 Context，如何获取 Context？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、直接传入 activity 本身，因为继承了 Context&lt;br&gt;
2、getApplication () 和 getApplicationContext ()&lt;br&gt;
 3、view.getContext，这个 context 对象一般是该 view 所在的 Activity 实例&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个应用程序有几个 Context？ ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应用 Context 数量 = Activity 数 + Service 数 + 1&lt;/p&gt;
&lt;h3 id=&#34;6-intent&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#6-intent&#34;&gt;#&lt;/a&gt; 6、Intent&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是 Intent？ ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用于 Android 同个应用程序中各个组件之间的交互，或者不同应用程序之间的交互。可以用来表明当前组件的思想和意图，比如想执行某个动作，想发送某些数据等等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显式 Intent 和隐式 Intent 的区别？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、显式指定意图，系统就会根据我们指定的意图，打开我们想打开的 Activity&lt;br&gt;
2、不指定特定的意图，而是通过清单文件里，每个 Activity 节点下事先配置好的（也就是 “Intent 过滤器”），由系统根据我们设定的 Intent，从系统所有 Activity 中选出最符合的我们要求的 Activity&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在隐式启动中 Intent 可以设置多个 action, 多个 category 吗？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、一个 Intent 只有一个 action，但可以有多个 category，只有当 action 和所有 category 和某个&lt;intent-filter&gt;都同时匹配，才算匹配成功。&lt;br&gt;
2、一个&lt;intent-filter&gt;可以设置一个或多个&lt;action&gt;，当 Intent 能和&lt;intent-filter&gt;的任意一个 action 匹配就算匹配成功；&lt;br&gt;
3、一个&lt;intent-filter&gt;可以设置一个或多个&lt;category&gt;，只有当 Intent 能和&lt;intent-filter&gt;的所有 category 匹配才算匹配成功；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;隐式 Intent 的匹配规则？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、如果没有指定 category，系统会默认设置为 android.intent.category.DEFAULT&lt;br&gt;
2、如果不希望自己的组件，如自定义的 XXXActivity 被其他应用程序调用，则清单文件中，XXXActivity 下面不要声明 &lt;intent-filter&gt; ，并且将该组件的 exported 属性设置为 false&lt;br&gt;
3、其他如上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Activity 之间传递数据的方式 Intent 是否有大小限制，如果传递的数据量偏大，有哪些方案？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概在 1M 左右，超过这个限制就会静默崩溃。偏大可以采用 ContentProvider（应用间）或文件缓存（应用内）&lt;/p&gt;
&lt;h3 id=&#34;7-8-handler异步消息机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#7-8-handler异步消息机制&#34;&gt;#&lt;/a&gt; 7、8、Handler 异步消息机制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍下 Handler 消息机制 ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Handler 会发送出一个一个消息，同时系统会根据每一个不同的消息进行不同的处理流程&lt;br&gt;
 1、Handler：主要作用是发送信息以及处理信息（为何发送还自己处理？），其中发送的信息叫作 Message，可以传递数据哦；&lt;br&gt;
2、MessageQueue：消息队列，由一个一个 Message 汇成，遵循先进先出规则，由 Looper 进行管理；&lt;br&gt;
3、Looper：从 MessageQueue 里读取消息，并按消息分发机制分配到目标 Handler 进行消息处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Handler 引起的内存泄露原因以及最佳解决方案 ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因：Handler 一般是作为 Activity 的内部类，可以发送延迟执行的消息，如果在延迟阶段，我们把 Activity 关掉，此时因为该 Activity 还被 Handler 这个内部类所持有，导致 Activity 无法被回收，没有真正退出并释放相关资源，因此就造成内存泄漏&lt;br&gt;
解决方案：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在 Acitivity 的 onDestroy () 中调用 handler.removeCallbacksAndMessages (null) 及时移除所有消息。更进一步是建议将 Handler 抽离出来作为 BaseHandler，然后每个 Activity 需要用到 Handler 的时候，就去继承 BaseHandler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？ ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ActivityThread.main () 方法中调用了 Looper.prepareMainLooper () ，该方法调用 prepare () 创建 Looper。因此主线程不是不需要创建 Looper，而是系统帮我们做了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Handler、Thread 和 HandlerThread 的差别 ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Handler：本文所学的知识，是 Android 的一种异步消息机制，负责发送和处理消息，可实现子线程和主线程的消息通讯&lt;br&gt;
 2、Thread：Java 的一个多线程类，是 Java 进程中最小执行运算单位，用于给子类继承，创建线程&lt;br&gt;
 3、HandlerThread：从名字看就知道是由前面两者结合起来的。可以理解为 “一个继承自 Thread 的 Handler 类”，因此本质上和父类一样是 Thread，但其内部直接实现了 Looper，我们可以直接在 HandlerThread 里面直接使用 Handler 消息机制。减少了手动调用 Looper.prepare () 和 Looper.loop () 这些方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子线程中怎么使用 Handler？ ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接使用 HandlerThread 类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么在子线程中创建 Handler 会抛异常？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不能在还没有调用 Looper.prepare () 方法的线程中创建 Handler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Handler 里藏着的 Callback 能干什么？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从消息队列获取到信息后，需要分配给对应的 Handler 去处理，总共有 3 种优先级。&lt;br&gt;
1、handleCallback (msg)：Message 里自带的 callback 优先级最高；对应 Handler 的 post 方法；&lt;br&gt;
2、mCallback.handleMessage (msg)：也就是 Handler.Callback 写法；&lt;br&gt;
3、handleMessage (msg)：重写 handlerMessage () 方法，优先级最低；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Handler 的 send 和 post 的区别？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、post 是属于 sendMessage 的一种赋值 callback 的特例&lt;br&gt;
 2、post 和 sendMessage 本质上没有区别，两种都会涉及到内存泄露的问题&lt;br&gt;
 3、post 方式配合 lambda 表达式写法更精简&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建 Message 实例的最佳方式 ⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、尽量复用 Message ，减少内存消耗：&lt;br&gt;
2、通过 Message 的静态方法 Message.obtain ()； 通过 Handler 的公有方法 handler.obtainMessage ()&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Message 的插入以及回收是如何进行的，如何实例化一个 Message 呢？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Message 往 MessageQueue 插入消息时，会根据 when 字段（相对时间）来判断插入的顺序&lt;br&gt;
 2、消息执行完成之后，会进行回收消息，回收消息可见 2.3 小节 recycleUnchecked () 函数，只是 Message 的成员变量设置为 0 或者 null&lt;br&gt;
3、使用 Message.obtain 方法，这是从缓存消息池链表里直接获取的实例，可以避免 Message 的重复创建&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;妙用 Looper 机制，或者你知道 Handler 机制的其他用途吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、将 Runnable post 到主线程执行；&lt;br&gt;
2、利用 Looper 判断当前线程是否是主线程；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Looper.loop () 死循环一直运行是不是特别消耗 CPU 资源呢？不会造成应用卡死吗？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android 应用程序的主线程在进入消息循环过程前，会在内部创建一个 Linux 管道，MessageQueue 没有消息时，便阻塞在 nativePollOnce () 方法里，此时主线程会释放 CPU 资源进入休眠状态，因此并不特别消耗 CPU 资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MessageQueue 中如何等待消息？为何不使用 Java 中的 wait/notify 来实现阻塞等待呢？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道延时消息的原理吗？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、信息插入会根据 when 属性（需要处理消息的相对时间）进行排序&lt;br&gt;
 2、取消息处理时，如果时间还没到，就休眠到指定时间；如果当前时间已经到了，就返回这个消息交给 Handler 去分发，这样就实现处理延时消息了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;handler postDelay 这个延迟是怎么实现的？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如何保证在 msg.postDelay 情况下保证消息次序？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;更新 UI 的方式有哪些 ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Activity.runOnUiThread(Runnable)&lt;br&gt;
2、View.post(Runnable)，View.postDelay(Runnable, long)&lt;br&gt;
3、Handler&lt;br&gt;
4、AsyncTask&lt;br&gt;
5、Rxjava&lt;br&gt;
6、LiveData&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程、Handler、Looper、MessageQueue 的关系？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个线程对应一个 Looper，同时对应一个 MessageQueue，对应多个 Handler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多个线程给 MessageQueue 发消息，如何保证线程安全？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;插入 Message 的时候使用 synchronized 机制加锁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;View.post 和 Handler.post 的区别？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道 IdleHandler 吗？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9-handlerthread&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#9-handlerthread&#34;&gt;#&lt;/a&gt; 9、HandlerThread&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;HandlerThread 是什么？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HandlerThread 是 Google 封装好的一个类，它的内部有自己的 Looper 对象，可以进行 Loop 轮询，用于执行多个耗时操作，而不需要多次开启线程，本质是使用 Handler 和 Looper 实现的。HandlerThread 需要配合 Handler，使用只能作为子线程使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HandlerThread 原理和使用场景？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要在线程中使用 Handler 异步消息机制，或者需要实现子线程和子线程之间的通讯（Handler 是主线程和子线程之间的通讯），那么就可以用 HandlerThread。&lt;/p&gt;
&lt;h3 id=&#34;10-asynctask&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#10-asynctask&#34;&gt;#&lt;/a&gt; 10、AsyncTask&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;AsyncTask 是什么？能解决什么问题 ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AsyncTask 是一个轻量级的异步任务类，可以在线程池里执行比较耗时的后台任务，然后把执行的进度和最后的结果传递给主进程，并在主进程中更新 UI&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给我谈谈 AsyncTask 的三个泛型参数作用以及它的一些方法作用。⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;给我说说 AsyncTask 的原理。⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;你觉得 AsyncTask 有不足之处吗？有何使用注意事项？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;11-intentservice&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#11-intentservice&#34;&gt;#&lt;/a&gt; 11、IntentService&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;IntentService 是什么？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IntentService 其实是继承与 Service 的类，内部是由 HandlerThread 实现。常用于处理异步请求，处理完子线程的耗时操作后，会自动执行 stopService ()。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IntentService 原理和使用场景？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适合多个任务需要按顺序，适用更高优先级的的后台任务，不容易被系统杀死的使用场景，比如离线下载场景，后台下载场景&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IntentService 和 Service 的区别 ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Service 不是单独的线程，如果在 onStartCommand () 中执行耗时操作可能发生 ANR，IntentService 会创建一个工作线程来处理多线程任务&lt;br&gt;
 2、Service 长期存在后台，结束需要主动调用 stopSelft () 来结束服务，而 IntentService 会在任务完成后默认调用 stopSelft () 直接退出&lt;br&gt;
 3、两者都可以是使用 startService () 启动，但 IntentService 不能 onBind ()&lt;/p&gt;
&lt;h3 id=&#34;12-fragment&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#12-fragment&#34;&gt;#&lt;/a&gt; 12、Fragment&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Fragment 是什么？和 Activity 的联系？生命周期如何？⭐⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释：Fragment 翻译为 “片段，破片”，可以理解为 “显示在 Activity 中的 Activity”，为解决 Android 碎片化而生。它可以作为一个 Activity 界面中独立的子界面，拥有自己的生命周期，也可以接受用户的触摸事件。我们可以在一个 Activity 界面上添加多个 Fragment 子界面，并且每个 Fragment 都可以动态的添加、删除、替换&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Activity 和 Fragment 之间如何通讯？Fragment 和 Fragment 之间如何通讯？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Fragment 的回退栈了解吗？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Fragment 的使用方式⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你有遇到过哪些关于 Fragment 的问题，如何处理的？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-binder&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#13-binder&#34;&gt;#&lt;/a&gt; 13、Binder&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍什么是 Binder 机制⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Binder 是 Android 中的一种跨进程通信机制，采用服务端 / 客户端结构，主要包含服务端、客户端、ServiceManager、Binder 驱动 4 大部分&lt;br&gt;
 Android 跨进程通信方法：&lt;br&gt;
1、共享内存：通过共享缓冲区直接映射到各个进程的虚拟地址空间，速度快。但实现比较复杂，进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；&lt;br&gt;
2、消息队列：提供了一种从一个进程向另一个进程发送一个数据块的方法，但需要进行 2 次数据拷贝，不适合频繁或者数据量大的情况；&lt;br&gt;
3、管道：分为有名 / 无名管道，在创建时分配一个 page 大小的内存，缓存区大小比较有限；&lt;br&gt;
4、信号量：一般作为一种锁机制，用于进程 / 线程同步；&lt;br&gt;
5、信号：更适合作为进程中断控制，而非数据交换；&lt;br&gt;
6、Socket/LocalSocket：允许位于同一主机（计算机）或使用网络连接起来的不同主机上的应用程序之间交换数据；&lt;br&gt;
7、Binder：Binder 是 Android 中的一种跨进程通信机制；&lt;br&gt;
8、匿名共享内存：在 Android 系统中，提供了独特的匿名共享内存子系统 Ashmem (Anonymous Shared Memory)，它利用了 Linux 的 tmpfs 文件系统（一种可以基于 RAM 或是 SWAP 的高速文件系统）来实现不同进程间的内存共享。有两个特点：能够辅助内存管理系统来有效地管理不再使用的内存块；通过 Binder 进程间通信机制来实现进程间的内存共享；&lt;br&gt;
9、File：通过文件进行多进程通信用法简单，但不适合高并发情况；&lt;br&gt;
10、ContentProvider：Android 四大组件之一，常用于进程间数据共享，特别是一对多的情况，不过受限于 AIDL；&lt;br&gt;
11、Bundle：很常见也很常用，但只能传输 Bundle 支持的数据类型，同样不适合大量数据的传输；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 Binder 机制流程 ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Binder 机制需要多少次内存拷贝 ⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Android 有很多跨进程通信方法，为何选择 Binder？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、性能：管道、消息队列、Socket 都需要 2 次数据拷贝 (即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区)，而 Binder 只要 1 次（可见第 3 节分析），且 Binder 相对 Socket 方法也更加高效，Socket 主要用于跨网络的进程间通讯，传输的效率比较低。当然共享内存 1 次数据拷贝都不需要，因此就性能而言，共享内存高于 Binder；&lt;br&gt;
2、安全：Android 系统为每个应用都分配各自的 UID 以鉴别不同进程。Binder 会验证权限，鉴定 UID/PID 来验证身份，保证了进程通信的安全性；&lt;br&gt;
3、稳定：共享内存 1 次数据拷贝都不需要，但实现的方法比较复杂，并且需要做好进程同步，容易出现死锁或者资源竞争，稳定性差。而 Binder 基于 C/S 架构，客户端和服务端彼此独立，稳定性强&lt;/p&gt;
&lt;h3 id=&#34;14-aidl&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#14-aidl&#34;&gt;#&lt;/a&gt; 14、AIDL&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍什么是 AIDL⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AIDL 全称 Android Interface Definition Language，也就是 Android 接口定义语言。因为 AIDL 的文件内容都是只有定义，而没有真正的实现。设计了这门语言是为了方便实现跨进程通讯，AIDL 文件的后缀是 “.aidl“&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有几种 AIDL 文件？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;一个程序 AIDL 文件的数量？ ⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你有没有使用过 AIDL？谈谈你如何实现的？ ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;知道 AIDL 语法中的定向 tag 吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你能不能简单描述 AIDL 实现的原理？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;15-sharedpreferences&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#15-sharedpreferences&#34;&gt;#&lt;/a&gt; 15、SharedPreferences&lt;/h3&gt;
&lt;p&gt;SharedPreferences 是基于 key-value 键值对生成的一个 xml 文件，保存在 /data/data/packageName/shared_prefs 目录下，适合保存少量数据，且数据格式相对简单。SharedPreferences 本身是一个接口，可以通过 getSharedPreferences () 获取实例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SharedPreference 是线程安全的吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SP 的读写操作是线程安全的，内部用了很多 synchronized 锁来实现线程同步，但进程不安全，Google 官方推荐使用 ContentProvider 来实现 SharedPreference 的进程同步&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SharedPreference 的 apply 和 commit 的区别？commit 一定会在主线程操作嘛？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改完内容后，在提交的时候分为 commit 和 apply，两者都会先把修改保存到内存，只不过 apply 是异步写磁盘，而 commit 可能是同步写磁盘也可能是异步写磁盘。commit 不一定在主线程执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SharedPreferences 是如何初始化的，它会阻塞主线程吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SharedPreferencesImpl 实例化过程会启动子线程从磁盘读取 xml 文件内容，读取时因是在子线程运行，所以不会阻塞主线程，但如果此时没读取完就开始获取或者修改数值，就会引起主线程阻塞&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次获取 SP 对象真的会很慢吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个应用有可能有多个 SP 的 xml 文件，实例一旦加载到内存后就一直保存在内存，直到这个进程销毁。但也因此如此，在 SharedPreferencesImpl 初始化的过程中会产生大量的临时对象，导致频繁 GC，引起界面卡顿，同时占用大量内存，因此大量数据时不建议用 SP。好处就是每次获取 SP 对象都很快。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用时需要注意哪些问题，以及有什么优化点呢？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SP 用于轻量数据存储操作，就非常的合适，大量数据时不建议用 SP，有助于减少卡顿 / ANR。JSON 或者 HTML 也不建议用 SP，应该直接用 JSON&lt;/p&gt;
&lt;h3 id=&#34;16-线程池&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#16-线程池&#34;&gt;#&lt;/a&gt; 16、线程池&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;线程池的种类⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓线程池就是事先创建一系列线程，把它们放在一个容器里，使用的时候直接从池子里拿线程，而不需要重新去 new 一个&lt;br&gt;
核心线程：当该线程处于闲置时间也不会回收&lt;br&gt;
非核心线程：等待时间超过 keepAliveTime 设定的时间就会被回收，核心线程需要执行 threadPoolExecutor.allowCoreThreadTimeOut (true) 后超过时间才会被回收&lt;br&gt;
 1、FixThreadPool：线程数量固定的线程池，只有核心线程（用于正规服务器）&lt;br&gt;
2、SingleThreadPool：单例线程池，任意时间内池中只有一个线程&lt;br&gt;
 3、CachedThreadPool：无界可自动回收线程池，核心线程数设置为 0，该线程池里所有的线程一旦处于闲置时间超过 60 秒就会被自动回收&lt;br&gt;
 4、ScheduledThreadPool：周期任务线程池，核心线程数固定，非核心线程则没有限制数量，非核心线程闲置时立刻回收&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程池的优点⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多次复用、最大并发数可控制、能够对线程进行管理，并提供定时执行以及定间隔循环执行等功能&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平时当中使用案例⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ThreadPoolExecutor 类有了解吗？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三部分view相关篇&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第三部分view相关篇&#34;&gt;#&lt;/a&gt; 第三部分：View 相关篇&lt;/h2&gt;
&lt;h3 id=&#34;17-activity-window-decorview以及viewroot层级关系&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#17-activity-window-decorview以及viewroot层级关系&#34;&gt;#&lt;/a&gt; 17、Activity、Window、DecorView 以及 ViewRoot 层级关系&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请讲述 Activity、Window、DecorView 以及 ViewRoot 之间的层级关系⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DecorView 什么时候可见？⭐⭐⭐⭐&lt;/p&gt;
&lt;h3 id=&#34;18-触摸事件分发机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#18-触摸事件分发机制&#34;&gt;#&lt;/a&gt; 18、触摸事件分发机制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍什么是事件分发机制，以及对应流程⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;谈谈你对 MotionEvent 的认识？Cancel 事件是什么情况下触发的⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;OnTouchListener &amp;amp; OnTouchEvent &amp;amp; OnClickListener 三者之间的关系⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;19-view绘制流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#19-view绘制流程&#34;&gt;#&lt;/a&gt; 19、View 绘制流程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请介绍 View 的三大绘制流程 ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道 View 绘制前的准备流程吗？⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是 MeasureSpec？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;测量模式有哪三种？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么有时候 getMeasuredWidth 获取值为 0？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;绘制的顺序是怎么样？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;20-自定义view&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#20-自定义view&#34;&gt;#&lt;/a&gt; 20、自定义 View&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义 View 的流程 ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义 View 需要重写哪些函数？说说你在自定义 View 时常常重写的一些方法？ ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义 View 的种类有哪些？给我说说你之前项目中的案例。⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;说说自定义 View 中如何自定义属性？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义 View 如何处理 padding？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义 View 效率高于 xml 布局文件吗？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义 View 什么时候需要处理 wrap_content 属性？怎么处理？⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第四部分android进阶篇&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第四部分android进阶篇&#34;&gt;#&lt;/a&gt; 第四部分：Android 进阶篇&lt;/h2&gt;
&lt;h3 id=&#34;21-序列化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#21-序列化&#34;&gt;#&lt;/a&gt; 21、序列化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;序列化是什么？序列化的作用？什么时候需要序列化？ ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象转换为字节流便于存储且便于传输&lt;br&gt;
 1、进行网络传输：将对象或者信息数据转换为字节流格式，特别是 Base64 格式，并通过网络传输给其他人&lt;br&gt;
 2、本地永久性存储：将对象转换为字节流并存放于内存，等到需要用到该对象的时候，再从内存读取字节流并再次构建出该对象&lt;br&gt;
 3、进行 IPC 传输：如需要将某个对象的信息传输给其他的进程，则需要先进行序列化，传输到其他进程后，再将其反序列化构建出原来的对象； 那么，针对将对象转换为字节流的过程称之为 “序列化”，而将字节流再次构建为对象的则是 “反序列化”&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Android 中序列化方式有几种？说说它们的区别。⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Serializable：Java 自带的序列化方法，通过实现 Serializable 接口来实现序列化。内部实现原理是通过 Java 的反射机制，该机制效率相对低，同时会产生很多临时对象，因此就需要频繁地进行垃圾回收&lt;br&gt;
 2、Parcelable：安卓专用的序列化方式，性能比 Serializable 高出 10 多倍，原理是把对象分解为 Intent 支持的数据类型，并通过 Intent 进行传输，其数据可以保存在内存中，相对于 Serializable 将数据保存在磁盘，效率自然更高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bunder 传递对象为什么需要序列化？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 bundle 传递数据时只支持基本数据类型，所以在传递对象时，需要先将对象进行序列化，转换成可存储或可传输的字节流&lt;/p&gt;
&lt;h3 id=&#34;22-jnindk&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#22-jnindk&#34;&gt;#&lt;/a&gt; 22、JNI/NDK&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是 JNI? 它主要用来干什么。 ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JNI（Java Native Interface）就是 Java 本地化接口，JNI 作为中间件可以让 Java 代码与本地系统的 C/C&lt;ins&gt; 代码做交互。&lt;br&gt;
NDK（Native Development Kit），翻译过来是 “本地开发工具”，可以理解为 Android 实现 JNI 的一种工具，通过该工具打包 C/C&lt;/ins&gt; 动态库并自动打包进 APK/AAR 中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java 声明的 Native 方法如何和 Native 层的 Native 函数进行绑定的？（也就是介绍两种注册方法）⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、静态注册的原理是：根据函数名建立 Java 方法和 JNI 函数的一一对应关系&lt;br&gt;
 2、动态注册的原理是通过使用 JNINativeMethod 结构来保存 Java 层声明的 native 方法和 Native 层函数的关联关系，直接告 Java 层声明的 native 方法其在 Native 层中对应函数的指针&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JNI 如何实现数据传递？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何全局捕获 Native 发生的异常？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;JNIEnv 与 JavaVM 的关系⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Android 每个进程只有一个 JavaVM 虚拟机对象，但可以有多个线程，当新线程第一次调用 JNI 函数时，虚拟机会给该线程生成一个 JNIEnv 指针。所以 JNIEnv 是线程局部存储，保证多线程之间的 JNI 通讯都是独立的。因此一个进程只有一个 JavaVM，但可能有多个 JNIEnv；&lt;br&gt;
2、JNIEnv 内部的函数执行环境来源于 Dalvik 虚拟机；&lt;br&gt;
当本地的 C/C++ 代码想要获得当前线程所想要使用的 JNIEnv 时，可以使用 Dalvik VM 对象的 JavaVM* jvm-&amp;gt;GetEnv () 方法，该方法会返回当前线程所在的 JNIEnv*；&lt;br&gt;
3、Java 的 dex 字节码和 C/C++ 的 .so 同时运行 Dalvik VM 之内，共同使用一个进程空间&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C 和 C++ 的 JNIEnv 的区别 ⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;JNI 项目配置和数据映射 ⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-设计模式使用案例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#23-设计模式使用案例&#34;&gt;#&lt;/a&gt; 23、设计模式使用案例&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;说说设计模式的六大原则。⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、单一职责原则：所谓职责是指类变化的原因，即一个类只负责一项职责，将一组相关性很高的函数、数据封装到一个类中&lt;br&gt;
 2、开闭原则：对于扩展是开放的，对于修改是关闭的，对模块行为进行扩展时，不必改动模块的源代码&lt;br&gt;
 3、里氏替换原则：使用 “抽象 (Abstraction)” 和 “多态 (Polymorphism)” 将设计中的静态结构改为动态结构，维持设计的封闭性。任何基类可以出现的地方，子类一定可以出现。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。&lt;br&gt;
4、依赖倒置原则：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合（各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的实现类）。&lt;br&gt;
5、接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。&lt;br&gt;
6、迪米特原则：又叫作最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。一个类应该对自己需要耦合或调用的类知道得最少，不关心被耦合或调用的类的内部实现，只负责调用你提供的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请简要谈一谈单例模式？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详见 Java 补漏&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请列出几种常见的工厂模式并说明它们的用法？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详见 Java 补漏&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态代理和动态代理的区别，什么场景使用？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态代理：代理类和目标类在代码中是确定的，因此称为静态。可以在不修改目标对象功能的前提下，对目标功能进行扩展&lt;br&gt;
动态代理：也叫 JDK 代理或接口代理，特点有&lt;br&gt;
 1、代理对象不需要实现接口&lt;br&gt;
 2、代理对象的生成是利用 JDK 的 API 动态的在内存中构建代理对象&lt;br&gt;
 3、能在代码运行时动态地改变某个对象的代理，并且能为代理对象动态地增加方法、增加行为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;谈一谈责任链模式的使用场景？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在安卓开发中随处可见，最经典的是触摸事件、按键事件的传递。这些触摸事件会一直传递下去，直到事件被消费为止&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请讲讲你会使用的一些设计模式？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;能否给我说说 Android 中至少 3 个用到设计模式的例子？ ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式（Handle Message）、抽象工厂模式（线程池构造）、观察者模式（ContentObserver）、责任链模式、装饰模式（ContextWrapper）&lt;/p&gt;
&lt;h3 id=&#34;24-apk启动流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#24-apk启动流程&#34;&gt;#&lt;/a&gt; 24、APK 启动流程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道桌面点击应用图标到应用显示期间系统实现了什么流程吗？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、点击桌面 App 图标，Launcher 进程采用 Binder 跨进程机制向 system_server 进程发起 startActivity 请求；&lt;br&gt;
2、system_server 进程接收到请求后，向 Zygote 进程发送创建进程的请求，Zygote 进程 fork 出新的子进程，即新启动的 App 进程；&lt;br&gt;
3、App 进程，通过 Binder 机制向 sytem_server 进程发起 attachApplication 请求（绑定 Application）；&lt;br&gt;
4、system_server 进程在收到请求后，进行一系列准备工作后，再通过 binder 机制向 App 进程发送 scheduleLaunchActivity 请求；&lt;br&gt;
5、App 进程的 binder 线程（ApplicationThread）在收到请求后，通过 handler 向主线程发送 LAUNCH_ACTIVITY 消息。主线程在收到 Message 后，通过发射 6、机制创建目标 Activity，并回调 Activity.onCreate ()/onStart ()/onResume () 等方法，经过 UI 渲染结束后便可以看到 App 的主界面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冷启动和热启动的区别 ⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;冷启动：重新分配一个进程&lt;br&gt;
热启动：应用虽然会退出，但是该应用的进程是依然会保留在后台&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;桌面点击启动 APP 和从另一个程序跳转过去有什么区别？⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种方法的原理都是通过 startActivity () 方法，唯一的区别在于桌面点击启动 APP 时的 intent 的 action 相对单一，而从另一个程序跳转或者启动的样式可能更多种&lt;/p&gt;
&lt;h3 id=&#34;25-mvc-mvp-mvvm&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#25-mvc-mvp-mvvm&#34;&gt;#&lt;/a&gt; 25、MVC、MVP、MVVM&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;说说你对 MVC、MVP、MVVM 的理解，他们有什么区别和联系，如何演变的？ ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、MVC&lt;br&gt;
（1）View：界面相关，将计人脸识别系统 UI 界面相关代码抽离出来，对应于 xml 布局文件&lt;br&gt;
（2）Controller：控制相关，将和 UI 界面操作相关以及判断相关的业务逻辑也抽离出来，比如判断用户是否输入姓名了，没有输入则不会开始采集用户照片等，对应于 Activity&lt;br&gt;
（3）Model：数据相关，具体的性别识别算法运算等较为复杂的运算，本地数据的维护等&lt;br&gt;
在实际的 Android 开发中，View 层对应 xml 布局文件，其实能做的事情特别少，实际上关于该布局文件中的数据绑定的操作，事件处理的代码都在 Activity 中，造成了 Activity 既像 View 又像 Controller，使得 Activity 变得臃肿&lt;/p&gt;
&lt;p&gt;2、MVP&lt;br&gt;
 在 MVC 的基础上，用 Presenter 代替 Controller：&lt;br&gt;
（1）View：不仅负责 UI 界面相关操作，还要负责用户交互，相当于 Activity&lt;br&gt;
（2）Model：依然主要负责数据处理&lt;br&gt;
（3）Presenter：负责 View 和 Model 之间的交互&lt;/p&gt;
&lt;p&gt;3、MVVM&lt;br&gt;
（1）Model：和 MVP 中的 Model 一样，还是用来处理数据的；&lt;br&gt;
（2）View：还是用来更新和处理 UI 界面以及和用户交互，相当于 Activity。和 MVP 里的 View 的区别在于，View 界面的更新从由 Presenter 驱动，变成了自动监听数据，随着数据变化而自动更新；&lt;br&gt;
（3）ViewModel：Model 和 View 的中介，处理逻辑中转任务的媒介。一个 View 可以绑定多个不同的 ViewModel，一个 ViewModel 也可以被多个 View 同时绑定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MVVM 的优点和缺点 ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、优点&lt;br&gt;
（1）数据和布局双向绑定，我们只需要关心数据数值的改变，而不再需要操心 findViewById 和 setText () 等繁复的代码的工作&lt;br&gt;
（2）一个 View 可以绑定多个 ViewModel，一个 ViewModel 可以供多个 View 绑定，提高复用性和灵活性&lt;br&gt;
（3）自带生命周期管理，不用担心因为生命周期而出现 bug&lt;/p&gt;
&lt;p&gt;2、缺点：&lt;br&gt;
（1）View 和 ViewModel 独立，如果出现 bug 定位问题较难&lt;br&gt;
（2）Binding 类的生成可能需要多次 Rebuild 的操作，若 Binding 类过多，则编译工作会耗时很大&lt;br&gt;
（3）需要提前设置好数据监听，如果数值多，那就要设置很多监听&lt;br&gt;
（4）如果 ViewModel 层数据未改变，但却强制要 View 层改变 UI 控件时，就比较麻烦&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么 Activity 旋转屏幕后 ViewModel 可以恢复数据 ⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ViewModel 的实例缓存到哪儿了 ⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;什么时候 ViewModel#onCleared () 会被调用 ⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;26-缓存机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#26-缓存机制&#34;&gt;#&lt;/a&gt; 26、缓存机制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;你了解 Android 中的缓存机制吗？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要为 LRU，有两种形式：LruCache 和 DisLruCache，前者实现了内存缓存，后者实现了磁盘缓存&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LruCache 的源码看过吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;还有用过哪些缓存工具？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;27-apk打包流程和反编译&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#27-apk打包流程和反编译&#34;&gt;#&lt;/a&gt; 27、APK 打包流程和反编译&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请讲述一下 APK 打包的流程？ ⭐⭐⭐⭐&lt;br&gt;
使用过哪些反编译的工具？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;28-注解&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#28-注解&#34;&gt;#&lt;/a&gt; 28、注解&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;你是否了解注解？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注解是 JDK 5 引入的，作为代码里的特殊标记。这些标记可以在代码编译、代码运行时执行特定的操作。注解和 public、static 等修饰符一样，都是程序元素的一部分。开发人员可以在不修改原来代码逻辑的情况下，通过注解来做到：&lt;br&gt;
1、降低项目的耦合度&lt;br&gt;
 2、自动完成一些规律性的代码&lt;br&gt;
 3、自动生成 java 代码，减轻开发者的工作量&lt;br&gt;
总结为一句话，注解就是用来简化代码，提高开发效率。如 @Override 表明函数是重写的，@Deprecated 表明函数被废弃&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你知道元注解吗？⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用来解释其它自定义注解的注解，也就是元注解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知道如何使用自定义注解吗？有哪些实现方法？⭐⭐⭐⭐&lt;br&gt;
具体说一下编译时注解的实现思路⭐⭐⭐⭐&lt;br&gt;
如何使用注解代替枚举？⭐⭐⭐&lt;br&gt;
你知道哪些常用的注解？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第五部分android性能优化篇&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第五部分android性能优化篇&#34;&gt;#&lt;/a&gt; 第五部分：Android 性能优化篇&lt;/h2&gt;
&lt;h3 id=&#34;29-内存优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#29-内存优化&#34;&gt;#&lt;/a&gt; 29、内存优化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是 OOM、内存泄漏、内存抖动？如何发生的？ ⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、内存泄漏：当一个对象 A 在程序中已经打算释放了，但有其他对象持有对象 A 的强引用，导致对象 A 不能正常被系统回收，继续占用着内存，如此反复使实际可使用内存越来越小&lt;br&gt;
 2、内存溢出：当内存使用量超过了虚拟机分配给当前程序的最大值时，就会发生内存溢出。出现这种情况很可能是加载的资源太多，如加载大图片，或者分配了很大的数组等变量，或者是太多的内存泄漏最终导致内存溢出&lt;br&gt;
 3、内存抖动：当内存频繁分配和回收导致内存不稳定，就会出现内存抖动，它通常表现为 频繁 GC、内存曲线呈锯齿状&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Handler 导致的内存泄露你是如何解决的？ ⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;知道如何定位内存泄漏吗？有什么工具？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android Studio 自带工具&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请至少例举出 5 种内存泄漏情况。⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Handler 内存泄漏、非静态内部类的静态实例（依赖外部类）、资源性对象（比如文件、图片、Cursor 等）、WebView、集合只增不减、单例对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Android 中如何避免内存泄漏？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、减小对象本身的内存占用&lt;br&gt;
 2、内存对象复用：使用到相同的对象或者资源，如果已经创建，则尽量复用以减少内存使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;谈谈你项目中内存优化的一些经验（开放题）⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;30-卡顿优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#30-卡顿优化&#34;&gt;#&lt;/a&gt; 30、卡顿优化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;造成系统卡顿的根本原因 ⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码设计、内存占用、CPU 使用率、IO 操作等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是 ANR ？导致原因有哪些？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Application Not Respongding，简称 ANR，翻译为中文即是 “应用程序无响应”，导致的原因有：&lt;br&gt;
1、主线程进行 IO 操作，引起阻塞&lt;br&gt;
 2、主线程执行耗时操作&lt;br&gt;
 3、主线程有错误操作，如 Thread.sleep 等直接导致主线程阻塞&lt;br&gt;
 4、执行速度缓慢的广播接收器&lt;br&gt;
 5、出现死锁&lt;br&gt;
 6、主线程使用 Binder 和另一个进程通讯，另一个进程需要很长时间才返回&lt;br&gt;
 7、主线程使用 SharedPrederence：SharedPrederence 调用 apply 方法，会创建一个等待锁放到 QueuedWork 中，并将真正数据持久化封装成一个任务放到异步队列中执行，任务执行结束会释放锁。Activity onStop 以及 Service 处理 onStop，onStartCommand 时，执行 QueuedWork.waitToFinish () 等待所有的等待锁释放。其实不管是 commit 还是 apply，都是在主线程进行 IO 操作，那么都是可能会产生 ANR 的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何避免发生 ANR ？⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;避免 ANR 的核心就是主线程中少执行耗时的代码，以及避免 CPU 使用率太高或者内存占用太高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分别说说 Activity、BroadcastReceiver、Serice 最长可耗时时间为多少？⭐⭐⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、Activity 在 5 秒内无响应用户操作&lt;br&gt;
 2、BroadCastReceiver 在 10 秒内未执行完所设置的操作，如果应用在后台，则延长到 60 秒&lt;br&gt;
 3、Service 在 20 秒没有执行完操作，如果应用在后台，则延长到 200 秒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;谈谈你项目中避免 ANR 的一些经验（开放题）⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有什么方法和工具可以分析 ANR ⭐⭐⭐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://onlie202.github.io/2024/03/14/Flutter%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/</guid>
            <title>Flutter基础与实战</title>
            <link>https://onlie202.github.io/2024/03/14/Flutter%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E6%88%98/</link>
            <category>Android</category>
            <category>Flutter</category>
            <pubDate>Thu, 14 Mar 2024 14:28:01 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;flutter基础与实战从入门到app跨平台开发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#flutter基础与实战从入门到app跨平台开发&#34;&gt;#&lt;/a&gt; Flutter 基础与实战：从入门到 APP 跨平台开发&lt;/h1&gt;
&lt;h2 id=&#34;第一章基础知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第一章基础知识&#34;&gt;#&lt;/a&gt; 第一章：基础知识&lt;/h2&gt;
&lt;h3 id=&#34;11-dart语言概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#11-dart语言概述&#34;&gt;#&lt;/a&gt; 1.1 Dart 语言概述&lt;/h3&gt;
&lt;p&gt;JIT 全称为 Just in Time（即时编译）&lt;/p&gt;
&lt;p&gt;AOT 全称为 Ahead of Time（事前编译）&lt;/p&gt;
&lt;p&gt;Flutter 在 Debug 模式下使用了 Kernel Snapshot 编译模式&lt;/p&gt;
&lt;p&gt;Dart 的 bytecode 模式，不区分架构，Flutter 项目内也叫作 Core Snapshot，可以归类为 AOT 编译&lt;/p&gt;
&lt;h3 id=&#34;12-dart语言核心&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#12-dart语言核心&#34;&gt;#&lt;/a&gt; 1.2 Dart 语言核心&lt;/h3&gt;
&lt;p&gt;强类型语言&lt;/p&gt;
&lt;p&gt;var、dynamic 用来声明动态类型变量&lt;/p&gt;
&lt;p&gt;var 一旦指定类型后，后期是不能再次修改类型的&lt;/p&gt;
&lt;p&gt;dynamic 关键字声明的数据类型与 JavaScript 中的一致&lt;/p&gt;
&lt;p&gt;number 类型分为 int 和 double&lt;/p&gt;
&lt;p&gt;没有 float 类型&lt;/p&gt;
&lt;p&gt;bool 类型相当于 Java 中的 boolean 与 Objective-C 中的 BOOL&lt;/p&gt;
&lt;p&gt;Dart 中也有箭头函数&lt;/p&gt;
&lt;p&gt;Map 用来存储对象类型的数据&lt;/p&gt;
&lt;p&gt;List 与 Set 用来存储数组类型的数据&lt;/p&gt;
&lt;h3 id=&#34;13-flutter项目配置文件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#13-flutter项目配置文件&#34;&gt;#&lt;/a&gt; 1.3 Flutter 项目配置文件&lt;/h3&gt;
&lt;p&gt;默认创建的 main.dart 就是 Flutter 项目的启动文件，main 函数就是程序启动入口，默认生成的 Flutter 页面是一个点击累加的计数器。&lt;/p&gt;
&lt;p&gt;pubspec 配置文件就是图 1-10 所示的⑱，该配置文件主要用来配置 Flutter 开发的一些依赖，&lt;/p&gt;
&lt;p&gt;environment 就是配置的当前项目的 Dart Sdk 开发环境&lt;/p&gt;
&lt;p&gt;属性 dependencies 之下就是配置依赖库这些信息了&lt;/p&gt;
&lt;p&gt;依赖库有两种，一种是纯 Dart 语言库，一种是插件类型的，包括 Android、iOS 双平台的内容。&lt;/p&gt;
&lt;p&gt;自定义的静态资源目录&lt;/p&gt;
&lt;p&gt;assets 文件夹名称可以自定义，此处根据 Android、iOS 原生习惯定义为 assets。&lt;/p&gt;
&lt;h3 id=&#34;14-flutter-app的调试技巧&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#14-flutter-app的调试技巧&#34;&gt;#&lt;/a&gt; 1.4 Flutter APP 的调试技巧&lt;/h3&gt;
&lt;p&gt;Flutter 项目的中的日志分为两类&lt;/p&gt;
&lt;p&gt;一类是 Android 原生与 iOS 原生中输出的日志信息&lt;/p&gt;
&lt;p&gt;一类是从 Dart 项目中输入的日志信息&lt;/p&gt;
&lt;p&gt;Flutter 有三种运行模式：Debug、Release、Profile，&lt;/p&gt;
&lt;p&gt;build 的时候是完全独立的&lt;/p&gt;
&lt;p&gt;Debug 模式可以在真机和模拟器上同时运行：会打开所有的断言，包括 debugging 信息、debugger aids（比如 observatory）和服务扩展，&lt;/p&gt;
&lt;p&gt;Release 模式只能在真机上运行&lt;/p&gt;
&lt;p&gt;这个模式是为了部署给最终用户使用的。命令 flutter run–release 就是以这种模式运行的。&lt;/p&gt;
&lt;p&gt;Profile 模式只能在真机上运行&lt;/p&gt;
&lt;p&gt;保留一些调试功能来配置应用程序的性能&lt;/p&gt;
&lt;p&gt;断点调试就是在每一行代码处打个断点，然后使用程序阻塞在断点处不执行，再调度该处对应的数据与逻辑&lt;/p&gt;
&lt;p&gt;Flutter Inspector 视图定位工具，就是在程序运行时，通过点击手机屏幕上运行的视图，可快速自动定位到当前视图中 Widget 对应的那一行实现代码，这个功能在大型项目中（一般有大量的代码块积累）非常适用，可以极大程度地节省开发者定位代码的时间消耗，由原来的手动检索代码过渡到现在的自动定位代码。&lt;/p&gt;
&lt;p&gt;Flutter Performance 内存管理工具可以实时跟踪应用程序的内存消耗&lt;/p&gt;
&lt;p&gt;退出这个页面后，内存用量没有下降，这就表明有内存泄漏&lt;/p&gt;
&lt;h2 id=&#34;第二章基础组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第二章基础组件&#34;&gt;#&lt;/a&gt; 第二章：基础组件&lt;/h2&gt;
&lt;p&gt;对于 Flutter 应用程序来讲，则是由若干个 Widget 组合起来的，它们组合到一起，形成一个 Widgets 树形结构，类似 dom 树&lt;/p&gt;
&lt;h3 id=&#34;21-materialapp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#21-materialapp&#34;&gt;#&lt;/a&gt; 2.1 MaterialApp&lt;/h3&gt;
&lt;p&gt;MaterialApp 组件是 Material Design 设计风格在 Flutter 中的体现，常用于开发 Material Design 设计风格的 APP&lt;/p&gt;
&lt;p&gt;MaterialApp 组件常用在 Widgets 树结构的顶层，或者可以理解为用来构建应用的根布局&lt;/p&gt;
&lt;p&gt;在 Android 原生开发中，要打开一个新的页面，先初始化一个 Intent，绑定目标页面的 class，然后调用 Context 的 startActivity 方法。&lt;/p&gt;
&lt;p&gt;打开一个新的页面有两种方式，一种是静态路由，一种是动态路由。&lt;/p&gt;
&lt;p&gt;静态路由&lt;/p&gt;
&lt;p&gt;routes 配置的是一个 Map，这个 Map 中 key 对应路由名称。value 对应路由页面&lt;/p&gt;
&lt;p&gt;通过 Navigator 的 pushNamed 方法打开对应的页面&lt;/p&gt;
&lt;p&gt;动态路由不通过 routes 配置，无指定的路由名字，在使用时直接使用 Navigator 来打开&lt;/p&gt;
&lt;p&gt;要退出当前 Widget 页面，有三种方式&lt;/p&gt;
&lt;p&gt;第一种是点击手机的返回按钮&lt;/p&gt;
&lt;p&gt;第二种是点击页面 AppBar 中默认的左上角的返回箭头&lt;/p&gt;
&lt;p&gt;第三种就是在页面中通过 Navigator 的 pop 方法&lt;/p&gt;
&lt;p&gt;将页面推出路由栈&lt;/p&gt;
&lt;p&gt;如果需要回传参数，可以直接写在 pop 方法中&lt;/p&gt;
&lt;p&gt;在回传数据与接收数据的地方，数据类型要保持一致&lt;/p&gt;
&lt;p&gt;需要注意在关闭当前页面时，最好判断一下当前页面是否是页面栈中的最后一个页面，也就是 Widgets 树中的最后一个 Widget，如果是的话，再强行执行 pop 方法，那么栈中就会无 Widget 页面，导致页面黑屏&lt;/p&gt;
&lt;p&gt;如果需要获取第二个页面关闭时回传到第一个页面的数据，可以使用 then 函数&lt;/p&gt;
&lt;p&gt;B 页面中获取 A 页面传递的数据需要在 didChangeDependencies 生命周期中获取&lt;/p&gt;
&lt;p&gt;因为这里使用了 context，所以不能在 initState 方法中获取，原因是在 initState 中 context 还未绑定成功。&lt;/p&gt;
&lt;p&gt;在动态路由中传值就比较方便了，可直接通过构造函数传值&lt;/p&gt;
&lt;p&gt;home 属性配置的 MyHomePage 就是当前 Flutter 应用启动加载的第一个 Flutter 页面。&lt;/p&gt;
&lt;p&gt;配置 Flutter 启动页面的方式二是在 MaterialApp 组件的属性 routes 中配置 “/”，然后指向需要默认打开的页面&lt;/p&gt;
&lt;p&gt;方式三是在 MaterialApp 组件的 initialRoute 属性中指定初始化打开的页面对应的路由&lt;/p&gt;
&lt;p&gt;initialRoute 指定的是静态路由的名称，这个名称需要在 routes 中配置后才能使用，&lt;/p&gt;
&lt;p&gt;这三种方式是互斥的，只允许单独配置使用&lt;/p&gt;
&lt;p&gt;配置 Flutter 默认启动页面的总结如下。&lt;/p&gt;
&lt;p&gt;通过 MaterialApp 的 home 属性来配置&lt;/p&gt;
&lt;p&gt;在 MaterialApp 的 routes 属性中配置 “/”&lt;/p&gt;
&lt;p&gt;通过 MaterialApp 的 initialRoute 属性&lt;/p&gt;
&lt;p&gt;如果需要配置为中文显示，首先需要添加 Flutter 应用的多语言功能支持。在配置文件 pubspec.yaml 中添加 localizations 多语言环境支持&lt;/p&gt;
&lt;p&gt;根布局视图下的 MaterialApp 组件中设置中文语言环境&lt;/p&gt;
&lt;p&gt;ThemeData 是在 Flutter 中对各组件样式的封装&lt;/p&gt;
&lt;p&gt;取值可为 ThemeMode.system 跟随当前系统的主题色&lt;/p&gt;
&lt;p&gt;primarySwatch 属性可以理解为一个基本的主要的配色设定&lt;/p&gt;
&lt;p&gt;primaryColor 可以理解为用来配置主颜色，AppBar 标题栏、TabBar 等一般是一个 Widget 页面的头，&lt;/p&gt;
&lt;p&gt;accentColor 可理解为引人注意的颜色，也可以理解为当前活跃的颜色，如 TabBar 的 indicator 指示线的颜色、开关 Switch 被选中后显示的高亮颜色等。&lt;/p&gt;
&lt;p&gt;highlightColor 是高亮颜色，如按下 Button 时显示的高亮颜色。&lt;/p&gt;
&lt;p&gt;splashColor 是点击反馈水波纹效果的颜色配置，例如点按 Button 显示的水波纹扩散的颜色。&lt;/p&gt;
&lt;h3 id=&#34;22-scaffold组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#22-scaffold组件&#34;&gt;#&lt;/a&gt; 2.2 Scaffold 组件&lt;/h3&gt;
&lt;p&gt;Scaffold 可称为脚手架，一般通过它搭建页面的基本结构&lt;/p&gt;
&lt;p&gt;header 头部，或者称之为标题栏&lt;/p&gt;
&lt;p&gt;body 体，可称之为内容主体页面&lt;/p&gt;
&lt;p&gt;bottom 脚，可称之为页面的尾部，比如 bottomBar。&lt;/p&gt;
&lt;p&gt;对于 Scaffold 来讲，它实现了基本的 Material Design 设计结构，一般可以用作单页面的主结构&lt;/p&gt;
&lt;p&gt;前两者的不同是它可以指定一个 Label 来显示文本，同时也限制了子 Widget 为 Icon 类型，对应添加子 Widget 的方式已不是 child，而是封装成 icon 属性，&lt;/p&gt;
&lt;p&gt;Scaffold 的属性 drawer 用来配置左侧侧拉页面，属性 endDrawe 配置右侧侧拉页面。&lt;/p&gt;
&lt;p&gt;此处左侧图标占用的是 AppBar 的 leading 属性，右侧占用的是 actions 属性&lt;/p&gt;
&lt;p&gt;bottomNavigationBar 属性来配置页面底部导航栏&lt;/p&gt;
&lt;p&gt;fixed 限制的切换效果是在导航栏菜单切换时，图标和文字标题会有微微缩放的动画效果，对于 shifting 来讲，切换动画效果更明显，在 shifting 模式下，只有当前选中的 item 的图标与文字才会显示出来&lt;/p&gt;
&lt;p&gt;也可以结合 BottomAppBar、TabBar 和 TabBarView 这样的组合来实现常见的首页底部菜单栏切换页面功能&lt;/p&gt;
&lt;p&gt;使用 BottomAppBar 组件可以自定义任意的子组件来实现菜单栏，在这里使用的是 TabBar 结合 Tab 的方式&lt;/p&gt;
&lt;h3 id=&#34;23-appbar&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#23-appbar&#34;&gt;#&lt;/a&gt; 2.3 AppBar&lt;/h3&gt;
&lt;p&gt;AppBar 组件的 title 属性是一个 Widget 类型，这就意味着可以定义任意的 Widget。&lt;/p&gt;
&lt;h3 id=&#34;24-文本显示text组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#24-文本显示text组件&#34;&gt;#&lt;/a&gt; 2.4 文本显示 Text 组件&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，Text 组件用于显示文本&lt;/p&gt;
&lt;p&gt;可以通过设置 Text 组件的 softWrap 属性来控制其是否自动换行&lt;/p&gt;
&lt;p&gt;TextStyle 中的 decoration 属性可用来配置文本中的下画线、删除线等装饰&lt;/p&gt;
&lt;p&gt;在 Flutter 中，使用 RichText 实现一段文本中多种文字风格的功能，类似 Android 中的 SpannableString 与 iOS 中的 NSMutableAttributedString。&lt;/p&gt;
&lt;p&gt;TextSpan 可以通过 children 属性来无限嵌套使用。使用此原理可开发一个用于显示搜索内容高亮颜色的依赖库 flutter_tag_layout，实际业务场景中就是搜索框搜索出的列表显示内容中有与关键字相同的内容就使用高亮颜色显示。&lt;/p&gt;
&lt;h3 id=&#34;25-文本输入框textfield组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#25-文本输入框textfield组件&#34;&gt;#&lt;/a&gt; 2.5 文本输入框 TextField 组件&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，组件 TextField 用来输入文本&lt;/p&gt;
&lt;p&gt;autofocus 用来配置是否自动获取输入焦点&lt;/p&gt;
&lt;p&gt;当页面中有 TextField 输入框时，手机键盘会自动弹出。&lt;/p&gt;
&lt;p&gt;TextField 默认情况下是有一个底部边框效果的，在实际项目开发中，是满足不了设计需要的。通过属性 decoration 配置 InputDecoration 可以定义更多效果&lt;/p&gt;
&lt;p&gt;通过 TextEditingController 可实现为绑定的输入框 TextField 预设内容、获取 TextField 中输入的内容、监听 TextField 中的文字输入变化等。&lt;/p&gt;
&lt;p&gt;EditingControlldr 也可以添加一个 Listener 监听，在当前的文本输入框 TextField 获取或者失去焦点、有文本输入时可监听到变化&lt;/p&gt;
&lt;p&gt;FocusNode 可以用来捕捉欲监听 TextField 的焦点，同时也可通过 FocusNode 来控制对应的 TextField 的焦点&lt;/p&gt;
&lt;p&gt;在实际项目中的一个用户操作习惯就是：当输入键盘是弹出状态时，用户点击屏幕的空白处，键盘要隐藏。实现思路就是在 MaterialApp 组件中的第一个根布局中设置一个手势监听，然后在手势监听中处理隐藏键盘的功能&lt;/p&gt;
&lt;h3 id=&#34;26-容器container组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#26-容器container组件&#34;&gt;#&lt;/a&gt; 2.6 容器 Container 组件&lt;/h3&gt;
&lt;p&gt;Container 组件是用来放置 widget 的容器，可以设置 padding、margin、位置、大小、边框和阴影等参数。&lt;/p&gt;
&lt;p&gt;Content（内容）：盒子的主内容区域，通过 child 属性来配置&lt;/p&gt;
&lt;p&gt;Container 可实现多种多样的装饰效果，如圆角边框、渐变背景、体育场背景等&lt;/p&gt;
&lt;p&gt;decoration 最常用的就是 BoxDecoration 盒模型装饰&lt;/p&gt;
&lt;h3 id=&#34;27-按钮button&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#27-按钮button&#34;&gt;#&lt;/a&gt; 2.7 按钮 Button&lt;/h3&gt;
&lt;p&gt;MaterialButton 是 Material Design 风格按钮，需要在 MaterialApp 组件中使用，它常用的按钮子类有 RaisedButton、FlatButton、OutlineButton。&lt;/p&gt;
&lt;h3 id=&#34;28-图片image组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#28-图片image组件&#34;&gt;#&lt;/a&gt; 2.8 图片 Image 组件&lt;/h3&gt;
&lt;p&gt;在 Flutter 中用来加载图片的组件有 AssetImage、DecorationImage、ExactAssetImage、FadeInImage、FileImage、NetworkImage、RawImage、MemoryImage、Image 等&lt;/p&gt;
&lt;p&gt;通过 Image.network 来加载网络图片，只需要传入对应的网络图片链接就可以&lt;/p&gt;
&lt;p&gt;也可以通过 NetworkImage 来配合 Image 加载网络图片&lt;/p&gt;
&lt;p&gt;在 Flutter 中，通过 Image.asset 来加载资源目录下的图片&lt;/p&gt;
&lt;h2 id=&#34;第三章布局&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第三章布局&#34;&gt;#&lt;/a&gt; 第三章：布局&lt;/h2&gt;
&lt;h3 id=&#34;31-线性布局column与row&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#31-线性布局column与row&#34;&gt;#&lt;/a&gt; 3.1 线性布局 Column 与 Row&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，使用 Row 和 Column 组件来实现水平或垂直方向的布局，Row 组件处理水平方向的布局，Column 组件处理垂直方向的布局。&lt;/p&gt;
&lt;p&gt;Row 和 Column 都有两根轴，MainAxisAlignment（主轴）和 CrossAxisAlignment（交叉轴）&lt;/p&gt;
&lt;p&gt;对于 Column 组件来讲，其作用是将子 Widget 在垂直方向线性排列，所以它的主轴就是垂直方向，水平方向就是它的交叉轴。对于 Row 来讲，其主轴就是水平方向，交叉轴就是垂直方向。&lt;/p&gt;
&lt;p&gt;主轴方向是填充&lt;/p&gt;
&lt;p&gt;交叉轴上是包裹&lt;/p&gt;
&lt;p&gt;当 Column 与 Row 的父布局有了宽高的限制后，Column 与 Row 在主轴与交叉轴方向上都是填充父布局的&lt;/p&gt;
&lt;p&gt;Column 与 Row 在主轴方向都是将子 Widget 以开始的位置对齐，在交叉轴方向都是居中对齐。&lt;/p&gt;
&lt;p&gt;结合 Expanded 组件使用后，第二个 Button 填充了水平方向剩余的所有的空白区域&lt;/p&gt;
&lt;p&gt;如果想要 Column 三个子 Widget 的高度相等，并且平均分配 Column 的空间，可结合 Expanded 组件来实现这种效果&lt;/p&gt;
&lt;p&gt;此处通过 Expanded 中配置的 flex 值，来决定子当前 Expanded 的子 Widget 占用的 height&lt;/p&gt;
&lt;p&gt;如在此处的三个区域内容中，Expanded 分别配置 flex 为 1，也就是会将当前 Column 的高度 height 平均分配成 3 份，然后每个子 Widget 占用一份，也就达到了等比分布的需求。&lt;/p&gt;
&lt;h3 id=&#34;32-非线性布局&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#32-非线性布局&#34;&gt;#&lt;/a&gt; 3.2 非线性布局&lt;/h3&gt;
&lt;p&gt;帧布局又可称为层叠布局，是将子 Widget 重叠在一起&lt;/p&gt;
&lt;p&gt;类似 Android 中的 Frame 布局&lt;/p&gt;
&lt;p&gt;Flutter 中弹性布局 Flex 的思想源于层叠样式表（Cascading Style Sheets，CSS）中。&lt;/p&gt;
&lt;p&gt;Column 继承于 Flex，配置 Flex 的 direction 属性为 Axis.vertical，Row 继承于 Flex，配置 Flex 的 direction 属性为 Axis. Horizontal。&lt;/p&gt;
&lt;p&gt;通过 Wrap 和 Flow 来支持流式布局，溢出部分则会自动折行&lt;/p&gt;
&lt;p&gt;对于 Flow 来讲，它能实现流式布局 Wrap 所实现的所有功能，它可以自定义任何布局的样式&lt;/p&gt;
&lt;h3 id=&#34;33-实现一个酷炫的登录页面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#33-实现一个酷炫的登录页面&#34;&gt;#&lt;/a&gt; 3.3 实现一个酷炫的登录页面&lt;/h3&gt;
&lt;p&gt;KeyboardPlaceholderWidget 是自定义封装的一个 Widget，这个组件的作用就是用来占位，它可以监听键盘的弹出与隐藏&lt;/p&gt;
&lt;h2 id=&#34;第四章功能性组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第四章功能性组件&#34;&gt;#&lt;/a&gt; 第四章：功能性组件&lt;/h2&gt;
&lt;h3 id=&#34;41-indicator&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#41-indicator&#34;&gt;#&lt;/a&gt; 4.1 Indicator&lt;/h3&gt;
&lt;p&gt;LinearProgressIndicator 是一个线性进度指示器 Widget&lt;/p&gt;
&lt;p&gt;当 value 为 null 时，进度条是一个线性的循环模式，表示正在加载；&lt;/p&gt;
&lt;p&gt;CircularProgressIndicator 是一个圆形循环的进度指示器 Widget，&lt;/p&gt;
&lt;h3 id=&#34;42-单选框radio-复选框checkbox-开关switch&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#42-单选框radio-复选框checkbox-开关switch&#34;&gt;#&lt;/a&gt; 4.2 单选框 Radio、复选框 CheckBox、开关 Switch&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，通过 Radio 组件来实现单选框效果&lt;/p&gt;
&lt;p&gt;RadioListTile 是一个用于便捷、快速构建列表样式的组件布局&lt;/p&gt;
&lt;p&gt;Switch 组件是 Material Design 设计风格的开关，CupertinoSwitch 是苹果设计风格的开关&lt;/p&gt;
&lt;h3 id=&#34;43-手势处理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#43-手势处理&#34;&gt;#&lt;/a&gt; 4.3 手势处理&lt;/h3&gt;
&lt;p&gt;在 Flutter 中，提供的 Button 系列组件自带手势识别功能，如监听用户的点击与长按，都会有相应的事件回调，然后开发者可以在相应的回调函数中处理响应操作逻辑。&lt;/p&gt;
&lt;p&gt;GestureDetector 的 onTap 方法监听的是手指抬起时的回调&lt;/p&gt;
&lt;p&gt;通过 InkWell 添加点击事件会有点击高亮以及水波纹效果，而通过 GestureDetector 实现的点击无点击效果出现&lt;/p&gt;
&lt;p&gt;实际项目开发中，通常只是普通的点击事件建议使用 InkWell 组件&lt;/p&gt;
&lt;p&gt;Ink 常与 InkWell 和 InkResponse 一起使用，用来配置点击效果的水波纹与高亮的样式，Ink 必须在 Material Design 风格下进行使用，所以一般使用 Material 组件配合 Ink 来使用&lt;/p&gt;
&lt;h2 id=&#34;第五章滑动视图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第五章滑动视图&#34;&gt;#&lt;/a&gt; 第五章：滑动视图&lt;/h2&gt;
&lt;p&gt;在 Flutter 中，通过 ScrollView 组件来实现滑动视图效果，当 ScrollView 的内容大于其本身 size 的时候，ScrollView 会自动添加滚动条，并可以竖直滑动&lt;/p&gt;
&lt;h3 id=&#34;51-scrollview&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#51-scrollview&#34;&gt;#&lt;/a&gt; 5.1 ScrollView&lt;/h3&gt;
&lt;p&gt;默认情况下，ScrollView 在竖直方向上下滑动&lt;/p&gt;
&lt;p&gt;可通过 physics 属性来修改为指定的效果&lt;/p&gt;
&lt;p&gt;SingleChildScrollView 适用于简单滑动视图处理，如 APP 中常见的商品详情页面、订单详情页面&lt;/p&gt;
&lt;p&gt;在 ScrollController 中可添加监听，然后实时获取滚动的距离，从而判断是否滚动到了顶部或者是底部，然后进行一些业务上的需求开发&lt;/p&gt;
&lt;p&gt;NestedScrollView 继承于 CustomScrollView，它比 SingleChildScrollView 更强大，可以用来实现诸如滑动折叠头部的功能，基本使用代码如下&lt;/p&gt;
&lt;p&gt;当一个页面中，既有九宫格布局 GridView 又有列表 ListView，二者有各自的滑动区域，不能进行统一滑动，可通过 CustomScrollView 将二者结合起来&lt;/p&gt;
&lt;p&gt;宫格布局 SliverGrid&lt;/p&gt;
&lt;p&gt;SliverGridDelegateWithFixedCrossAxisCount，这个 delegate 是用来根据指定的每行显示多少列 Item，而依次换行显示，不同屏幕分辨率下的手机显示的列数是一样&lt;/p&gt;
&lt;p&gt;SliverGridDelegateWithMaxCrossAxisExtent，这个 delegate 是根据每个 Item 允许的最大宽度然后依次排列每个 Item，也就是不同屏幕分辨率下的手机显示的列数不一样&lt;/p&gt;
&lt;p&gt;SliverChildListDelegate 用来构建少量 Item 的应用场景，在使用这个 delegate 时，会将使用到的 Item 一次性构建出来。&lt;/p&gt;
&lt;p&gt;SliverChildBuilderDelegate 用来构建大量 Item 的应用场景，在使用时，只会构建手机屏幕上显示的 Item，不会构建屏幕以外未显示的 Item，所以是懒加载方式。&lt;/p&gt;
&lt;h3 id=&#34;52-pageview&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#52-pageview&#34;&gt;#&lt;/a&gt; 5.2 PageView&lt;/h3&gt;
&lt;p&gt;PageView 可用于 Widget 的整屏滑动切换，如当下流行的短视频 APP 中的上下滑动切换功能，也可用于横向页面的切换，如 APP 第一次安装时的引导页面，也可用于开发轮播图功能&lt;/p&gt;
&lt;h3 id=&#34;53-listview与gridview&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#53-listview与gridview&#34;&gt;#&lt;/a&gt; 5.3 ListView 与 GridView&lt;/h3&gt;
&lt;p&gt;ListView 是最常用的可滚动列表，GridView 用来构建二维网格列表，两者都继承自 BoxScrollView&lt;/p&gt;
&lt;p&gt;ListView 有 4 种创建方式，描述如下&lt;/p&gt;
&lt;p&gt;默认构造函数（传入 List children）&lt;/p&gt;
&lt;p&gt;通过 ListView.builder 方式来创建，适用于有大量数据的情况&lt;/p&gt;
&lt;p&gt;通过 ListView.custom 方式来构建，提供了自定义子 Widget 的能力。&lt;/p&gt;
&lt;p&gt;通过 ListView.separated 方式来创建，可以配置分割线，适用于具有固定数量列表项的 ListView。&lt;/p&gt;
&lt;p&gt;实际项目业务开发中，第二种方式使用得比较多，通常称为懒加载模式，适合列表项比较多的情况，因为只有当子组件真正显示的时候才会被创建&lt;/p&gt;
&lt;p&gt;ListView.separated 可以在生成的列表项之间添加一个分割组件，它比 ListView.builder 多了一个 separatorBuilder 参数，该参数是一个分割组件生成器，常用于列表 Item 之间有分隔线的场景&lt;/p&gt;
&lt;p&gt;GridView 创建方法有五种，描述如下。&lt;/p&gt;
&lt;p&gt;GridView 构造函数方法，一次性构建所有子条目，适用于少量数据。&lt;/p&gt;
&lt;p&gt;GridView.builder 方式来构建，懒加载模式，适用于大量数据的情况。&lt;/p&gt;
&lt;p&gt;GridView.count 方式来构建，适用于固定列的情况，适用于少量数据。&lt;/p&gt;
&lt;p&gt;GridView.extent 方式来构建，适用于条目有最大宽度限制的情况，适用于少量数据的情况。&lt;/p&gt;
&lt;p&gt;GridView.custom 方式来构建，可配置子条目的排列规则，也可配置子条目的渲染加载模式。&lt;/p&gt;
&lt;p&gt;下拉刷新与上拉加载更多 RefreshIndicator 是 Material 风格的滑动刷新 Widget，在 ListView 与 GridView 的外层直接嵌套使用即可&lt;/p&gt;
&lt;h2 id=&#34;第六章动画&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第六章动画&#34;&gt;#&lt;/a&gt; 第六章：动画&lt;/h2&gt;
&lt;h3 id=&#34;61-基本动画&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#61-基本动画&#34;&gt;#&lt;/a&gt; 6.1 基本动画&lt;/h3&gt;
&lt;p&gt;通过 AnimatedOpacity 组件可实现基本的透明度变化动画，适用于简单过渡业务场景&lt;/p&gt;
&lt;h3 id=&#34;63-其他动画概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#63-其他动画概述&#34;&gt;#&lt;/a&gt; 6.3 其他动画概述&lt;/h3&gt;
&lt;p&gt;Android、iOS、JS、Flutter 中都可以使用 Canvas 画布结合 Path 路径来绘制任意想要的自定义图形，再结合动画，就可以实现更加酷炫的效果&lt;/p&gt;
&lt;p&gt;在 Flutter 中，通过 PathMetric 来度量完整的 Path 路径，PathMetric 可以获取完整的 Path 路径下任意一截的数据，形成新的 Path 路径。&lt;/p&gt;
&lt;h2 id=&#34;第七章弹框&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第七章弹框&#34;&gt;#&lt;/a&gt; 第七章：弹框&lt;/h2&gt;
&lt;h3 id=&#34;71-基本弹框的使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#71-基本弹框的使用&#34;&gt;#&lt;/a&gt; 7.1 基本弹框的使用&lt;/h3&gt;
&lt;p&gt;showDialog 方法是 Material 组件库提供的一个用于弹出 Material 风格弹框的方法&lt;/p&gt;
&lt;p&gt;SimpleDialog 是一个适用于有列表排列的弹框选项的情况&lt;/p&gt;
&lt;p&gt;showGeneralDialog 方法用来完全自定义显示的弹框内容&lt;/p&gt;
&lt;p&gt;showBottomSheet 用来在视图底部弹出一个 Material Design 风格的对话框&lt;/p&gt;
&lt;p&gt;showModalBottomSheet 用来在视图底部弹出一个 Modal Material Design 风格的对话框&lt;/p&gt;
&lt;h3 id=&#34;72-dialog中的状态更新&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#72-dialog中的状态更新&#34;&gt;#&lt;/a&gt; 7.2 Dialog 中的状态更新&lt;/h3&gt;
&lt;p&gt;AlertDialog 中使用到了单选框，点击切换时却发现是无法切换选项的，原因是在弹出的弹框构建出新的 StatelessWidget，与当前页面的 StatefulWidget 或者 StatelessWidget 是平级的，直接使用 setState 是调用当前页面的更新操作，而未调用到新的 StatelessWidget 中对应的 State。&lt;/p&gt;
&lt;p&gt;解决方案一就是将弹框中需要更新状态的内容单独封装&lt;/p&gt;
&lt;p&gt;解决方式二就是结合 StatefulBuilder 来实现&lt;/p&gt;
&lt;h2 id=&#34;第八章绘图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第八章绘图&#34;&gt;#&lt;/a&gt; 第八章：绘图&lt;/h2&gt;
&lt;p&gt;在 Flutter 中，绘图需要用到 CustomPaint 和 CustomPainter，CustomPainter 可理解为画板，用来承载画布，CustomPaint 可理解为画布，承载绘制的具体内容。&lt;/p&gt;
&lt;h3 id=&#34;83-贝塞尔曲线&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#83-贝塞尔曲线&#34;&gt;#&lt;/a&gt; 8.3 贝塞尔曲线&lt;/h3&gt;
&lt;p&gt;个点构成一个基本的直线，可称为一阶贝塞尔曲线&lt;/p&gt;
&lt;p&gt;这两个点之间的线段被一个其他的点牵引后，形成曲线，如图 8-13 所示称为二阶贝塞尔曲线&lt;/p&gt;
&lt;h2 id=&#34;第九章插件开发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第九章插件开发&#34;&gt;#&lt;/a&gt; 第九章：插件开发&lt;/h2&gt;
&lt;p&gt;在 Flutter 中，插件类型分为三种：Flutter Plugin、Flutter Package、Flutter Module&lt;/p&gt;
&lt;p&gt;对于 Flutter Plugin，在 Flutter 中使用 Dart 语言开发移动应用，一套代码可以同时适用 Android 和 iOS 两种环境，但是 Dart 不会编译成 Android Dalvik 字节码，在 iOS 上也不会有 Dart/Objective-C 的绑定，也就是意味着 Dart 代码并不会直接访问平台特定的 API，即 iOS Cocoa Touch 以及 Android SDK 的 API。&lt;/p&gt;
&lt;p&gt;开发插件包是用来开发调用特定平台的 API 包，这个插件包包含针对 Android（Java 或 Kotlin 代码）或 iOS（Objective-C 或 Swift 代码）编写的特定于平台的功能实现（可以同时包含 Android 和 iOS 原生的代码），如加载 H5 的 WebView、调用自定义相机、录音、蓝牙等。&lt;/p&gt;
&lt;h3 id=&#34;91-flutter与原生android-ios双向通信&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#91-flutter与原生android-ios双向通信&#34;&gt;#&lt;/a&gt; 9.1 Flutter 与原生（Android、iOS）双向通信&lt;/h3&gt;
&lt;p&gt;所谓双向通信，此处是指在 Flutter 中调用 Android 与 iOS，以及在原生 Android 与 iOS 中调用 Flutter，也就是数据的双向传输。&lt;/p&gt;
&lt;p&gt;常用的 Flutter 与 Android、iOS 原生的通信有以下三种方式。 1）BasicMessageChannel 用于传递字符串和半结构化的信息。 2）MethodChannel 用于传递方法调用，当然也可传输参数。 3）EventChannel 用于数据流 Event Streams 的通信。&lt;/p&gt;
&lt;p&gt;对于 MethodChannel，官方 API 中解析为 “A named channel for communicating with platform plugins using asynchronous method calls…”，也就是用来实现 Flutter 与原生 Android、iOS 通信。&lt;/p&gt;
&lt;p&gt;在实际项目开发中，可以考虑全局注册使用一个 MethodChannel 就好&lt;/p&gt;
&lt;p&gt;Flutter 项目中，Android 目录下的 MainActivity 就是对应的启动 Activity，可以直接在 MainActivity 中设置方法监听&lt;/p&gt;
&lt;p&gt;对应的 getMethodCallHandler 方法就是通过匿名内部类的方式创建一个 MethodCallHandler 回调对象&lt;/p&gt;
&lt;p&gt;这里从 Flutter 发送数据到 Android 中，发送的数据格式要与 Android 中接收的数据类型一致&lt;/p&gt;
&lt;p&gt;对于 BasicMessageChannel，也可用来实现 Flutter 与原生 Android、iOS 通信，与 MethodChannel 的区别是 MethodChannel 针对于方法调用使用，BasicMessageChannel 针对于消息数据来使用&lt;/p&gt;
&lt;p&gt;在 Flutter 应用项目的 Android 目录下的 MainActivity 中，一是要接收 Flutter 中发送过来的消息并做出回应消息，二是要主动多次地向 Flutter 中发送消息&lt;/p&gt;
&lt;p&gt;也可通过 BasicMessageChannel 来主动向 Flutter 中发送消息，代码如下&lt;/p&gt;
&lt;p&gt;当在 Android 中注册了 EventChannel 消息通道后，可通过 EventChannel.EventSink 向 Flutter 中发送消息&lt;/p&gt;
&lt;p&gt;EventChannel 通道适用于频繁发送消息的情景，此处使用定时器模拟实时传输数据的情况&lt;/p&gt;
&lt;h2 id=&#34;第十章进阶&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第十章进阶&#34;&gt;#&lt;/a&gt; 第十章：进阶&lt;/h2&gt;
&lt;h3 id=&#34;101-异步编程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#101-异步编程&#34;&gt;#&lt;/a&gt; 10.1 异步编程&lt;/h3&gt;
&lt;p&gt;在 Flutter 开发中，使用 async 关键字开启一个异步开始处理，使用 await 关键字来等待处理结果&lt;/p&gt;
&lt;p&gt;这个结果通常是一个 Future 对象。Future 表示延迟计算的对象&lt;/p&gt;
&lt;p&gt;Future 用于表示将来某个时间可用的潜在值或错误，也就是用来处理异步结果。&lt;/p&gt;
&lt;p&gt;如处理一个网络请求，或者是加载一个图片、文件，需要异步加载，通过 async 与 await 的组合可以实现这个操作&lt;/p&gt;
&lt;p&gt;综上所述，串行调用两个异步任务的一般写法如下所示&lt;/p&gt;
&lt;p&gt;也可以用 Future 提供的 then 函数&lt;/p&gt;
&lt;p&gt;在 Flutter 中实现延时操作有两种方式，一种是通过 Future，另一种是通过 Timer&lt;/p&gt;
&lt;p&gt;Future 的 then 函数返回值类型为一个 Future 对象，所以支持链式调用，组合在一起就是串行方式调用&lt;/p&gt;
&lt;p&gt;假如在 then 函数中任何一个环节出现了异常，那么后续的函数将会被中断执行&lt;/p&gt;
&lt;p&gt;Future 的 whenComplete 方法，类似于 try-catch-finally 中的 finally 块，所以使用 whenComplete 来结束多个异步操作是一个合适的解决方案&lt;/p&gt;
&lt;p&gt;源码的角度来看，Future 中实现的延时操作也是通过 Timer 来实现的，在实际开发中，如果只是一个单纯的延时操作，建议使用 Timer&lt;/p&gt;
&lt;p&gt;Future 用来处理异步操作结果，在注册回调时，通常的做法是分别注册两个回调，首先使用 then 和一个参数（值处理程序），然后使用第二个 catchError 处理错误。&lt;/p&gt;
&lt;p&gt;Flutter 的构造方法描述如下&lt;/p&gt;
&lt;p&gt;1）通过构造方法来创建&lt;/p&gt;
&lt;p&gt;2）创建一个延迟指定时间的异步任务&lt;/p&gt;
&lt;p&gt;3）创建一个错误回调，如在异步任务中判断为错误的结果时，可使用此方法&lt;/p&gt;
&lt;p&gt;4）microtask 方法用于将任务添加到主消息任务队列中，&lt;/p&gt;
&lt;p&gt;5）sync 方法用于将任务添加到当前的消息任务队列中&lt;/p&gt;
&lt;p&gt;6）value 方法用于将一个普通的计算结果构建成一个 Future 对象体。&lt;/p&gt;
&lt;p&gt;Future 的 doWhile 方法用来循环执行一定量的任务，可以是同步的任务也可以是异步的任务&lt;/p&gt;
&lt;p&gt;1）Timer 默认构造函数创建的是一个倒计时的功能（延时功能）&lt;/p&gt;
&lt;p&gt;2）Timer.periodic 创建的是一个间隔一定时间的计时器。&lt;/p&gt;
&lt;p&gt;3）静态方法 run 用来快速创建一个任务添加到当前任务队列中，相当于使用 Timer 默认构造创建的一个 Duration.zero 无延迟的任务执行。&lt;/p&gt;
&lt;p&gt;大部分操作系统（如 Windows、Linux）的任务调度是采用时间片轮转的抢占式调度方式&lt;/p&gt;
&lt;p&gt;任务执行的一小段时间叫作时间片，任务正在执行时的状态叫作运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来，任务的停与执行切换，称之为任务调度。&lt;/p&gt;
&lt;p&gt;操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），进程是资源分配的最小单位，也就是操作系统的最小单位。&lt;/p&gt;
&lt;p&gt;线程是进程中的概念，一个进程中可包含多个线程，任务调度采用的是时间片轮转的抢占式调度方式，进程是任务调度的最小单位。默认情况下，一般一个进程里只有一个线程，进程本身就是线程，所以线程可以被称为轻量级进程。&lt;/p&gt;
&lt;p&gt;协程是一种基于线程，但又是比线程更加轻量级的存在，是线程中的概念，一个线程可以拥有多个协程。&lt;/p&gt;
&lt;p&gt;传统的 J2EE 体系中，都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务），所以系统的吞吐能力取决于每个线程的操作耗时&lt;/p&gt;
&lt;p&gt;如果遇到很耗时的 I/O 行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多，会存在很多其他的线程在等待的情况，空闲状态（等待前面的线程执行完才能执行）造成了资源应用不彻底。&lt;/p&gt;
&lt;p&gt;最常见的例子就是同步阻塞的 JDBC&lt;/p&gt;
&lt;p&gt;连接过程中线程根本没有利用 CPU 去做运算，而是处在等待状态，而另外过多的线程，也会带来更多的 ContextSwitch（上下文切换）开销&lt;/p&gt;
&lt;p&gt;协程的作用下，当出现长时间的 I/O 操作时，协程通过让出当前占用的任务通道，执行下一个任务的方式，在线程中实现任务调度&lt;/p&gt;
&lt;p&gt;从编程角度上看，协程的思想本质上就是控制流的主动让出（Yield）和恢复（Resume）机制。&lt;/p&gt;
&lt;p&gt;点击 APP 图标启动时，手机操作系统会为当前 APP 创建一个进程&lt;/p&gt;
&lt;p&gt;Dart 是基于单线程模型的语言，所以在 Flutter 中，一般的异步操作实际上还是通过单线程通过调度任务优先级来实现的。&lt;/p&gt;
&lt;p&gt;Dart 中的线程机制被称为 isolate&lt;/p&gt;
&lt;p&gt;在 Flutter 项目中，运行中的 Flutter 程序由一个或多个 isolate 组成，默认情况下启动的 Flutter 项目，通过 main 函数启动就是创建了一个 main isolate，它 Flutter 的主线程，或者是 UI 线程。&lt;/p&gt;
&lt;p&gt;单线程模型中主要就是在维护着一个事件循环（Event Loop）与两个队列（event queue 和 microtask queue）。当 Flutter 项目程序触发如点击事件、I/O 事件、网络事件时，它们就会被加入 eventLoop 中，eventLoop 一直在循环之中，当主线程发现事件队列不为空时，就会取出事件，并且执行。&lt;/p&gt;
&lt;p&gt;microtask queue（主队列）只处理在当前 isolate 中的任务，优先级高于 event queue&lt;/p&gt;
&lt;p&gt;当事件正在循环处理 microtask 事件时，event queue（事件队列）会被堵塞。这时候 APP 就无法进行 UI 绘制，响应鼠标事件和 I/O 等事件。&lt;/p&gt;
&lt;p&gt;主队列和事件队列这两个任务队列中的任务切换机制与协程调度机制是一致的。&lt;/p&gt;
&lt;p&gt;Future 就是 event，每一个被 await 标记的句柄也是一个 event，timer 创建的任务也是一个 event，每创建一个 Future 就会把这个 Future 扔进 event queue 中排队。&lt;/p&gt;
&lt;p&gt;使用 Future 的 microtask 方法用于将任务添加到 microtask queue 任务队列中。&lt;/p&gt;
&lt;p&gt;FutureBuilder 用于将 Future 处理结果与 UI 数据刷新显示完美地结合在一起&lt;/p&gt;
&lt;p&gt;在构造 FutureBuilder 时，不能在 State.build 或 StatelessWidget.build 方法调用期间创建它，如果 Future 与 FutureBuilder 同时创建，那么每次重新构建 FutureBuilder 的父类时，都会重新启动异步任务。&lt;/p&gt;
&lt;h3 id=&#34;102-文件file的读写&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#102-文件file的读写&#34;&gt;#&lt;/a&gt; 10.2 文件 File 的读写&lt;/h3&gt;
&lt;p&gt;在 Flutter 工程项目中可以自定义资源文件的存储目录，如图 10-4 所示，只需要在配置文件中做好路径配置即可。&lt;/p&gt;
&lt;p&gt;每个 Flutter 应用程序都有一个默认创建的 rootBundle 对象，通过它可以轻松访问主资源包&lt;/p&gt;
&lt;p&gt;DefaultAssetBundle 来获取当前 BuildContext 的 AssetBundle。这种方法不是使用应用程序构建的默认 asset bundle，而是使父级 Widget 在运行时动态替换的不同的 AssetBundle，&lt;/p&gt;
&lt;p&gt;Dart 的 I/O 库包含了文件读写的相关类，所以对于文件的读写操作是需要导入 I/O 库。&lt;/p&gt;
&lt;p&gt;手机磁盘上的文件读写，首先要获取磁盘上开放的对应的目录空间，在这里使用插件 PathProvider 来实现这个操作&lt;/p&gt;
&lt;p&gt;临时目录：系统可随时清除的临时目录（缓存）。在 Android 上，对应 getCacheDir ()&lt;/p&gt;
&lt;p&gt;文档目录：对应 Android 的 AppData 目录&lt;/p&gt;
&lt;p&gt;在 Android 平台中，可以获取外部存储目录空间，iOS 则不支持&lt;/p&gt;
&lt;p&gt;File 文件存储适用于保存到这样的目录下，如应用程序必备的升级功能，需要将安装包数据先保存到文档目录中，再如音乐、视频一类的 APP，需要将媒体数据通过 File 保存到磁盘上&lt;/p&gt;
&lt;p&gt;还有一些轻量级的数据，如用户的基本信息、对应用的偏好设置信息，这些数据量小，权重也比较高，可以使用数据存储 SharedPreferences，需要在 pubspec.yaml 中添加相关依赖&lt;/p&gt;
&lt;p&gt;Sharedpreferences 是 Android 平台上一个轻量级的存储类，用来保存一些轻量级数据，如应用程序的各种配置信息，时以 “键 - 值” 对的方式（或者说是 key-value 的形式）保存数据的 xml 文件，其文件保存在 /data/data/ 应用包名 /shared_prefs 目录下&lt;/p&gt;
&lt;p&gt;需要注意的是，在使用 Sharedpreferences 时，首先是异步获取 Sharedpreferences 的实例&lt;/p&gt;
&lt;p&gt;针对列表数据，适合使用数据库来缓存。&lt;/p&gt;
&lt;p&gt;此处使用插件 sqflite 来实现这个操作&lt;/p&gt;
&lt;p&gt;在实际项目开发中，数据库可以在适当的一个版块业务结束后再关闭，或者是应用程序退出时再关闭，因为数据库的频繁打开与关闭也是一种性能消耗。&lt;/p&gt;
&lt;h3 id=&#34;103-网络请求库&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#103-网络请求库&#34;&gt;#&lt;/a&gt; 10.3 网络请求库&lt;/h3&gt;
&lt;p&gt;Dart I/O 库中提供了用于发起 Http 请求的一些类，可以直接使用 HttpClient 来发起请求&lt;/p&gt;
&lt;p&gt;Dio 是一个支持 Restful API、FormData、拦截器、请求取消、Cookie 管理、文件上传 / 下载、超时等功能的封装网络框架。&lt;/p&gt;
&lt;p&gt;Dio post 请求提交 FormData 表单数据，FormData 将提交的参数 name 与 value 进行组合，实现表单数据的序列化，从而减少表单元素的拼接。&lt;/p&gt;
&lt;p&gt;在应用开发中，会有像 token、appVersionCode 等这些每个接口请求都需要传的参数，称之为公共请求参数&lt;/p&gt;
&lt;p&gt;Dio 配置 Content-Type 与请求 header，创建 Dio 对象时，会初始化一个 BaseOptions 来创建 Dio，通过 BaseOptions 可以来设置请求头&lt;/p&gt;
&lt;p&gt;业务开发场景中，例如退出一个页面时，如果网络请求没完成，就会形成内存泄漏，所以需要在页面销毁时，取消网络请求，或者是在下载一个文件时，时间太长了，用户点击取消，就需要取消网络连接&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
